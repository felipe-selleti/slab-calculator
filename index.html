<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Esforços em Lajes</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>

	  * { box-sizing: border-box; margin: 0; padding: 0; }

    body, html {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background: #fff;
      display: flex;
      min-height: 90vh;
    }
	#intro, #calculator {
	  width: 100%;
	  height: 100%; 
	  position: absolute; 
	  top: 0; 
	  left: 0;  
	}
	#intro { 
	  display: flex;
	  align-items: center;
	  justify-content: center;
	  background: #fff;
	  color: #fff;
	  text-align: center;
	  padding: 20px;
	}
	#intro .content { 
	  max-width: 800px;
	}
	#intro h1 {
      color: #333;
	  font-size: 3.5rem;
	  margin-top: 10%;
	  margin-bottom: 1%;
	}
	#intro h2 { 
	  font-size: 1.5rem;
	  margin-bottom: 10%;
	}
	#intro p {
      color: #4F4F4F;
      font-size: 1rem;
	  margin-bottom: 7%;
	  line-height: 1.5;
	}
    #intro button {
	  padding: 0.75rem 1.5rem;
	  font-size: 1rem; border: none;
	  border-radius: 20px;
	  cursor: pointer;
	  background-color: #ffca28;
	  color: #333;
	}
	#intro .footer {
	  color: #333;
	  margin-top: 2rem;
	  font-size: 0.75rem;
	  opacity: 0.7; 
	}
	#calculator {
  	  visibility: hidden;
      opacity: 0;
      transition: opacity .3s;
    }
	#calculator.active {
      visibility: visible;
      opacity: 1;
    }
	#calculator .top-bar {
	  display: flex;
	  justify-content: space-between;
	  align-items: center;
      padding: 10px 20px;
	  background: #f5f5f5;
	  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
	  position: relative;
    }
	.top-bar__title {
	  position: absolute;
	  left: 50%;
	  transform: translateX(-50%);
	  font-size: 1.5rem;
	  font-weight: bold;
	  color: #333;
	  pointer-events: none;
	}
    #calculator .top-bar button {
	  margin: 0;
	}
    .layout {
      display: flex;
      align-items: flex-start;
	  width: 100vw;
    }
    .container1 {
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      padding: 15px;
      width: 13%;
	  height: 92%;
      margin-left: 0.3%;
      margin-right: 0.3%;
      margin-top: 1%;
      margin-bottom: 1%;
	  flex-wrap: nowrap;
    }
    .container2 {
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
	  padding: 15px;
      width: 28%;
	  height: 92%;
      margin-left: 0.3%;
      margin-right: 0.4%;
      margin-top: 1%;
      margin-bottom: 1%;
	  flex-wrap: nowrap;
    }
    h1 {
      font-size: 20px;
      text-align: center;
      color: #333;
      margin-bottom: 3%;
    }
	.container1 h1 {
 	  margin-bottom: 11%;
	}
	h2 {
      margin-top: 5px;
	  text-align: center;
      color: #333;
      font-size: 14px;
      margin-bottom: 12px;
    }
	.container1 h2 {
 	  margin-bottom: 10%;
	}
    .input-row {
      display: flex;
      gap: 10px;
	  margin-top: 12px;
      flex-wrap: wrap;
    }
    .input-box {
	  justify-content: center;
      background: #e6f7ff;
      border-radius: 15px;
      padding: 10px;
      width: 100%;
      flex: 1;
    }
	.dimensao,
	.carregamento,
	.engaste {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      margin-left: 10px;
    }
    .dimensao label,
	.carregamento label,
	.engaste label {
	  font-size: 14px;
      margin-right: 4px;
      margin-left: 4px;
      min-width: 25px;
      color: #555;
    }
    .dimensao input[type="number"],
    .carregamento input[type="number"] {
      width: 50%;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 15px;
      font-size: 14px;
    }
    .engaste input[type="checkbox"] {
      margin-right: 3px;
    }
    #canvas1,
	#canvas2,
	#canvas3 {
      margin: 2px auto;
      border-radius: 12px;
      display: flex;
      width: 100%;
	  height: 23vw;
	  margin-bottom: 1%;
    }
    .output-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
	  margin-bottom: 3%;
	  margin-top: 3%;
    }
	.output-box {
	  text-align: center;
	  justify-content: center;
      background: #e6f7ff;
      border-radius: 15px;
      padding: 10px;
      width: 100%;
      flex: 1;
    }
	.momentos-box {
	  text-align: center;
	  justify-content: center;
      background: #e6f7ff;
      border-radius: 15px;
      padding: 10px;
      width: 100%;
	  flex: 1;
    }
	.lambda,
	.epsilon,
	.coeficientes,
	.momentos {
      display: flex;
      align-items: center;
	  justify-content: center;
	  text-align: center;
      margin-bottom: 5px;
	  font-size: 14px;
    }
	.lambda label,
	.epsilon label,
	.coeficientes label,
	.momentos label {
      margin-right: 3px;
      color: #555;
    }
    #calculator .footer {
	  position: relative;
	  bottom: 0;
	  width: 100%;
      text-align: center;
	  padding: 10px;
	  font-size: .75rem;
	  color: #333;
	  background: rgba(255,255,255,0.8);
	}
	button.back, button#exportButton {
	  margin: 10px;
	  padding: 0.5rem 1rem;
	  font-size: 0.875rem;
	  border: none;
	  border-radius: 25px;
	  cursor: pointer;
	  background-color: #ddd;
	}
    button#startBtn {
	  display: inline-block;
	  padding: 0.75rem 1.5rem;
	  font-size: 1rem;
	  border: none;
	  border-radius: 30px;
	  cursor: pointer;
	  background-color: #007BFF;
	  color: #fff;
	}
  </style>
</head>
<body>

  <section id="intro">
    <div class="content">
      <h1>Calculadora de Lajes</h1>
      <h2><i>Slab Calculator</i></h2>
      <p>Esta ferramenta foi desenvolvida por Felipe Almada Selleti, sob orientação do professor Dr. Roberto Dalledone Machado no ano de 2025. É um produto do Trabalho Final de Curso de Engenharia Civil da Universidade Federal do Paraná.</p>
	  <p>Permite calcular os esforços em lajes utilizando diferentes abordagens: o Método de Marcus, o Método de Czerny e o Método das Chaneiras Plásticas. Ideal para estudantes e profissionais de engenharia civil.</p>
      <p>Para utilizá-la, insira as dimensões da laje, o carregamento e configure os apoios para obter os resultados dos momentos solicitantes.</p>
      <button id="startBtn">Iniciar Calculadora</button>
      <p class="footer">© Copyright 2025 - Todos os direitos reservados a Felipe Selleti</p>
    </div>
  </section>
  <section id="calculator">
    <div class="top-bar">
      <button class="back" id="backBtn">← Voltar</button>
	  <div class="top-bar__title">Calculadora de Lajes</div>
      <button id="exportButton">Exportar Resultados (.csv)</button>
    </div>
	<div class="layout">
    <div class="container1">
      <h1>Dados de Entrada</h1>
      <div class="input-row">
        <div class="input-box">
          <h2>Dimensões (m)</h2>
          <div class="dimensao">
            <label for="lx">Lx = </label>
            <input type="number" id="lx" value="4" min="1" step="0.04">
          </div>
          <div class="dimensao">
            <label for="ly">Ly =</label>
            <input type="number" id="ly" value="4" min="1" step="0.04">
          </div>
	    </div>
	  </div>
	  <div class="input-row">
		<div class="output-box">
		  <div class="lambda">
		    <label for="lambda">λ =</label>
			<div id="lambdaMarcusoutput"></div>
		  </div>
		  <div class="epsilon">
		    <label for="epsilon">ε =</label>
			<div id="epsilonoutput"></div>
		  </div>
        </div>
      </div>
      <div class="input-row">
        <div class="input-box">
          <h2>Carregamento (kN/m²)</h2>
          <div class="carregamento">
            <label for="q">q =</label>
            <input type="number" id="q" value="0" min="0" step="0.02">
          </div>
        </div>
      </div>
      <div class="input-row">
        <div class="input-box">
          <h2>Opções de Engaste</h2>
          <div class="engaste">
            <input type="checkbox" id="engaste1">
              <label for="engaste1">Lado 1</label>
          </div>
          <div class="engaste">
            <input type="checkbox" id="engaste2">
              <label for="engaste2">Lado 2</label>
          </div>
          <div class="engaste">
            <input type="checkbox" id="engaste3">
            <label for="engaste3">Lado 3</label>
          </div>
          <div class="engaste">
            <input type="checkbox" id="engaste4">
            <label for="engaste4">Lado 4</label>
          </div>
        </div>
      </div>
	  <div class="input-row">
	    <div class="input-box">
          <div class="coeficientes">
            <label for="tipodelaje">Tipo de Laje: </label>
            <div id="tipoLajeOutput"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="container2">
	  <h1>Método de Marcus</h1>
      <canvas id="canvas1"></canvas>
      <div class="output-row">
		<div class="output-box">
          <h2>Coeficientes m</h2>
          <div class="coeficientes">
            <label for="mx">m<sub>x</sub> =</label>
            <div id="mxMarcusoutput"></div>
          </div>
          <div class="coeficientes">
            <label for="my">m<sub>y</sub> =</label>
            <div id="myMarcusoutput"></div>
          </div>
		</div>
		<div class="output-box">
		<h2>Coeficientes n</h2>
          <div class="coeficientes">
            <label for="nx">n<sub>x</sub> =</label>
            <div id="nxMarcusoutput"></div>
          </div>
          <div class="coeficientes">
            <label for="ny">n<sub>y</sub> =</label>
            <div id="nyMarcusoutput"></div>
          </div>
        </div>
	  </div>  
      <div class="output-row">
		<div class="momentos-box">
          <h2>Momentos Positivos</h2>
          <div class="momentos">
            <label for="Mx">M<sub>x<sup>+</sup></sub> =</label>
            <div id="MxpositivoMarcusoutput"></div>
          </div>
          <div class="momentos">
            <label for="My">M<sub>y<sup>+</sup></sub> =</label>
            <div id="MypositivoMarcusoutput"></div>
          </div>
		</div>
		<div class="momentos-box">
          <h2>Momentos Negativos</h2>
          <div class="momentos">
            <label for="Xx">M<sub>x<sup>–</sup></sub> =</label>
            <div id="MxnegativoMarcusoutput"></div>
          </div>
          <div class="momentos">
            <label for="Xy">M<sub>y<sup>–</sup></sub> =</label>
            <div id="MynegativoMarcusoutput"></div>
          </div>
        </div>
      </div>
	</div>
    <div class="container2">
      <h1>Método de Czerny</h1>
	  <canvas id="canvas2"></canvas>
      <div class="output-row">
		<div class="output-box">
          <h2>Coeficientes m</h2>
          <div class="coeficientes">
            <label for="mx">m<sub>x</sub> =</label>
            <div id="mxCzernyoutput"></div>
          </div>
          <div class="coeficientes">
            <label for="my">m<sub>y</sub> =</label>
            <div id="myCzernyoutput"></div>
          </div>
		</div>
		<div class="output-box">
		<h2>Coeficientes n</h2>
          <div class="coeficientes">
            <label for="nx">n<sub>x</sub> =</label>
            <div id="nxCzernyoutput"></div>
          </div>
          <div class="coeficientes">
            <label for="ny">n<sub>y</sub> =</label>
            <div id="nyCzernyoutput"></div>
          </div>
        </div>
	  </div>  
      <div class="output-row"> 
		<div class="momentos-box">
		  <h2>Momentos Positivos</h2>
          <div class="momentos">    
            <label for="Mx">M<sub>x<sup>+</sup></sub> =</label>
            <div id="MxpositivoCzernyoutput"></div>
          </div>
          <div class="momentos">
            <label for="My">M<sub>y<sup>+</sup></sub> =</label>
            <div id="MypositivoCzernyoutput"></div>
          </div>
		</div>
		<div class="momentos-box">
		  <h2>Momentos Negativos</h2>
          <div class="momentos">
            <label for="Mx">M<sub>x<sup>–</sup></sub> =</label>
            <div id="MxnegativoCzernyoutput"></div>
          </div>
          <div class="momentos">
            <label for="My">M<sub>y<sup>–</sup></sub> =</label>
            <div id="MynegativoCzernyoutput"></div>
          </div>
        </div>
      </div>
    </div>
	<div class="container2">
      <h1>Método das Charneiras Plásticas</h1>
	  <canvas id="canvas3"></canvas>
      <div class="output-row">
		<div class="output-box">
		<h2>Coeficientes m</h2>
          <div class="coeficientes">
            <label for="mx">m<sub>x</sub> =</label>
            <div id="mxRupturaoutput"></div>
          </div>
          <div class="coeficientes">
            <label for="my">m<sub>y</sub> =</label>
            <div id="myRupturaoutput"></div>
		  </div>
		</div>
		<div class="output-box">
		<h2>Coeficientes n</h2>
          <div class="coeficientes">
            <label for="nx">n<sub>x</sub> =</label>
            <div id="nxRupturaoutput"></div>
          </div>
          <div class="coeficientes">
            <label for="ny">n<sub>y</sub> =</label>
            <div id="nyRupturaoutput"></div>
          </div>
		</div>
	  </div>  
      <div class="output-row">
		<div class="momentos-box">
		  <h2>Momentos Positivos</h2>
          <div class="momentos">    
            <label for="Mx">M<sub>x<sup>+</sup></sub> =</label>
            <div id="MxpositivoRupturaoutput"></div>
          </div>
          <div class="momentos">
            <label for="My">M<sub>y<sup>+</sup></sub> =</label>
            <div id="MypositivoRupturaoutput"></div>
          </div>
		</div>
		<div class="momentos-box">
		  <h2>Momentos Negativos</h2>
          <div class="momentos">
            <label for="Mx">M<sub>x<sup>–</sup></sub> =</label>
            <div id="MxnegativoRupturaoutput"></div>
          </div>
          <div class="momentos">
            <label for="My">M<sub>y<sup>–</sup></sub> =</label>
            <div id="MynegativoRupturaoutput"></div>
          </div>
        </div>
      </div>
    </div>
    </div>
	<div class="footer">© Copyright 2025 - Todos os direitos reservados a Felipe Selleti</div>
  </section>
  <script>
	
	// Organização das páginas e botões para ir e voltar entre elas
    const intro = document.getElementById('intro');
    const calc = document.getElementById('calculator');
	document.getElementById('startBtn').addEventListener('click', () => {
      intro.style.display = 'none';
      calc.classList.add('active');
    });
    document.getElementById('backBtn').addEventListener('click', () => {
      calc.style.display = 'none';
      intro.style.display = 'flex';
    });
	  
	//Constantes para desenhar a laje para cada método
    const scale = 25; // 1 metro = 25 pixels
    const canvas1 = document.getElementById('canvas1');
	const canvas2 = document.getElementById('canvas2');
	const canvas3 = document.getElementById('canvas3');
    const ctx1 = canvas1.getContext('2d');
    const ctx2 = canvas2.getContext('2d');
	const ctx3 = canvas3.getContext('2d');
	  
    // Função para melhorar a resolução do desenho da laje
    function fixDpi(canvas, ctx) {
      const dpi = window.devicePixelRatio || 1;
      const style_height = canvas.clientHeight;
      const style_width = canvas.clientWidth;
      canvas.width = style_width * dpi;
      canvas.height = style_height * dpi;
      ctx.scale(dpi, dpi);
    }

    // Função para desenhar as cotas ao lado da laje
    function drawArrow(ctx, fromx, fromy, tox, toy) {
      const headlen = 10;
      const dx = tox - fromx;
      const dy = toy - fromy;
      const angle = Math.atan2(dy, dx);
      ctx.beginPath();
      ctx.moveTo(fromx, fromy);
      ctx.lineTo(tox, toy);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tox, toy);
      ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(tox, toy);
      ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
      ctx.stroke();
    }

    // Função para obter o tipo de laje conforme os apoios
    function getTipoLaje() {
      const engaste1 = document.getElementById("engaste1").checked;
      const engaste2 = document.getElementById("engaste2").checked;
      const engaste3 = document.getElementById("engaste3").checked;
      const engaste4 = document.getElementById("engaste4").checked;

      const chave = (engaste1 ? 1 : 0) +
                    (engaste2 ? 2 : 0) +
                    (engaste3 ? 4 : 0) +
                    (engaste4 ? 8 : 0);

      const mapeamento = {
        0: 1,    // 0000: sem engastes
        1: 2,    // 0001: apenas lado 1
        2: 3,    // 0010: apenas lado 2
        4: 4,    // 0100: apenas lado 3
        8: 5,    // 1000: apenas lado 4
        3: 6,    // 0011: lados 1 e 2
        6: 7,    // 0110: lados 2 e 3
        12: 8,   // 1100: lados 3 e 4
        9: 9,    // 1001: lados 1 e 4
        5: 10,   // 0101: lados 1 e 3
        10: 11,  // 1010: lados 2 e 4
        7: 12,   // 0111: lados 1, 2 e 3
        14: 13,  // 1110: lados 2, 3 e 4
        13: 14,  // 1101: lados 1, 3 e 4
        11: 15,  // 1011: lados 1, 2 e 4
        15: 16   // 1111: todos os lados
      };

      return mapeamento[chave];
    }
	
    // Configura eventos para o Método de Marcus
	document.getElementById('lx').addEventListener('input', computeMarcus);
    document.getElementById('ly').addEventListener('input', computeMarcus);
	document.getElementById('q').addEventListener('input', computeMarcus);
    document.getElementById('engaste1').addEventListener('change', computeMarcus);
    document.getElementById('engaste2').addEventListener('change', computeMarcus);
    document.getElementById('engaste3').addEventListener('change', computeMarcus);
    document.getElementById('engaste4').addEventListener('change', computeMarcus);
	window.addEventListener('load', () => {
      fixDpi(canvas1, ctx1);
      computeMarcus();
    });
	
	// Configura eventos para o Método de Czerny
    document.getElementById('lx').addEventListener('input', computeCzerny);
    document.getElementById('ly').addEventListener('input', computeCzerny);
	document.getElementById('q').addEventListener('input', computeCzerny);
    document.getElementById('engaste1').addEventListener('change', computeCzerny);
    document.getElementById('engaste2').addEventListener('change', computeCzerny);
    document.getElementById('engaste3').addEventListener('change', computeCzerny);
    document.getElementById('engaste4').addEventListener('change', computeCzerny);
    window.addEventListener('load', () => {
      fixDpi(canvas2, ctx2);
      computeCzerny();
    });
	  
	// Configura eventos para o Método das Charneiras Plásticas
    document.getElementById('lx').addEventListener('input', computeCharneiras);
    document.getElementById('ly').addEventListener('input', computeCharneiras);
	document.getElementById('q').addEventListener('input', computeCharneiras);
    document.getElementById('engaste1').addEventListener('change', computeCharneiras);
    document.getElementById('engaste2').addEventListener('change', computeCharneiras);
    document.getElementById('engaste3').addEventListener('change', computeCharneiras);
    document.getElementById('engaste4').addEventListener('change', computeCharneiras);
    window.addEventListener('load', () => {
      fixDpi(canvas3, ctx3);
      computeCharneiras();
    });
	  
	// Função que desenha a laje e faz os cálculos para o método de Marcus
    function computeMarcus() {
		
	  //Desenho da laje
      const cw = canvas1.clientWidth;
      const ch = canvas1.clientHeight;
      const lx = parseFloat(document.getElementById('lx').value) * scale;
      const ly = parseFloat(document.getElementById('ly').value) * scale;
      ctx1.clearRect(0, 0, cw, ch);
	
      // Centraliza o retângulo
      const x = (cw - lx) / 2;
      const y = (ch - ly) / 2;

      // Desenha o retângulo principal
      ctx1.strokeStyle = '#333';
      ctx1.lineWidth = 2;
      ctx1.strokeRect(x, y, lx, ly);

      // Desenha as cotas
      const offset = 20;
      ctx1.lineWidth = 1;
      ctx1.beginPath();
      ctx1.moveTo(x, y - offset);
      ctx1.lineTo(x + lx, y - offset);
      ctx1.stroke();
      drawArrow(ctx1, x, y - offset, x + lx, y - offset);
      drawArrow(ctx1, x + lx, y - offset, x, y - offset);
      ctx1.font = '14px Roboto';
      ctx1.fillStyle = '#007BFF';
      ctx1.textAlign = 'center';
      ctx1.fillText(`Lx = ${(lx / scale).toFixed(2)} m`, x + lx / 2, y - offset - 10);

      ctx1.beginPath();
      ctx1.moveTo(x - offset, y);
      ctx1.lineTo(x - offset, y + ly);
      ctx1.stroke();
      drawArrow(ctx1, x - offset, y, x - offset, y + ly);
      drawArrow(ctx1, x - offset, y + ly, x - offset, y);
      ctx1.save();
      ctx1.translate(x - offset - 10, y + ly / 2);
      ctx1.rotate(-Math.PI / 2);
      ctx1.textAlign = 'center';
      ctx1.fillText(`Ly = ${(ly / scale).toFixed(2)} m`, 0, 0);
      ctx1.restore();

      // Desenha os engastes (linhas vermelhas)
      ctx1.lineWidth = 5;
      ctx1.strokeStyle = 'red';
      if (document.getElementById('engaste1').checked) {
        ctx1.beginPath();
        ctx1.moveTo(x, y);
        ctx1.lineTo(x, y + ly);
        ctx1.stroke();
      }
      if (document.getElementById('engaste2').checked) {
        ctx1.beginPath();
        ctx1.moveTo(x, y);
        ctx1.lineTo(x + lx, y);
        ctx1.stroke();
      }
      if (document.getElementById('engaste3').checked) {
        ctx1.beginPath();
        ctx1.moveTo(x + lx, y);
        ctx1.lineTo(x + lx, y + ly);
        ctx1.stroke();
      }
      if (document.getElementById('engaste4').checked) {
        ctx1.beginPath();
        ctx1.moveTo(x, y + ly);
        ctx1.lineTo(x + lx, y + ly);
        ctx1.stroke();
      }


    //Cálculos
    const tipo_m = getTipoLaje();
    const lx_m = parseFloat(document.getElementById('lx').value);
    const ly_m = parseFloat(document.getElementById('ly').value);
    const q_m = parseFloat(document.getElementById('q').value);
	const MN = computeMN(tipo_m);
    const lambda = computeLambda(lx_m, ly_m);
	const K = computeK(lambda.lambda1, lambda.lambda2, tipo_m);
	const V = computeV(tipo_m, MN.mx, MN.my, K.kx, K.ky, lambda.lambda1, lambda.lambda2);
	const CoeficientesMlNl = computeCoeficientesMlNl(tipo_m, MN.mx, MN.my, MN.nx, MN.ny, K.kx, K.ky, V.Vx, V.Vy, lambda.lambda1, lambda.lambda2);
	const Momentos = computeMomentos(q_m, lx_m, CoeficientesMlNl.mlx, CoeficientesMlNl.mly, CoeficientesMlNl.nlx, CoeficientesMlNl.nly);
	
	  // Resultados (Lambda)
      document.getElementById('lambdaMarcusoutput').innerText =
        `${lambda.lambda1.toFixed(2)}`;
	
      // Resultados (Coeficientes m'x, m'y, n'x e n'y)
      document.getElementById('mxMarcusoutput').innerText =
        `${CoeficientesMlNl.mlx.toFixed(3)}`;
	  document.getElementById('myMarcusoutput').innerText =
        `${CoeficientesMlNl.mly.toFixed(3)}`;
      document.getElementById('nxMarcusoutput').innerText =
        `${CoeficientesMlNl.nlx.toFixed(3)}`;
	  document.getElementById('nyMarcusoutput').innerText =
        `${CoeficientesMlNl.nly.toFixed(3)}`;
		
	  // Resultados (Momentos Solicitantes)
      document.getElementById('MxpositivoMarcusoutput').innerText =
        `${Momentos.Mxp.toFixed(3)} kN.m`;
      document.getElementById('MypositivoMarcusoutput').innerText =
        `${Momentos.Myp.toFixed(3)} kN.m`;
      document.getElementById('MxnegativoMarcusoutput').innerText =
        `${Momentos.Mxn.toFixed(3)} kN.m`;
      document.getElementById('MynegativoMarcusoutput').innerText =
        `${Momentos.Myn.toFixed(3)} kN.m`;
	  
	function computeMN(tipo) {
	  let mx, my, nx, ny;
	  if (tipo === 1) {
	    mx = 8;
		my = 8;
		nx = 0;
		ny = 0;
	  } else if (tipo === 2 || tipo === 3 || tipo === 4 || tipo === 5) {
		mx = 14.22;
		my = 8;
		nx = 8;
		ny = 0;
	  } else if (tipo === 6 || tipo === 7 || tipo === 8 || tipo === 9) {
		mx = 14.22;
		my = 14.22;
		nx = 8;
		ny = 8;
	  } else if (tipo === 10 || tipo === 11) {
		mx = 24;
		my = 8;
		nx = 12;
		ny = 0;
	  } else if (tipo === 12 || tipo === 13 || tipo === 14 || tipo === 15) {
		mx = 24;
		my = 14.22;
		nx = 12;
		ny = 8;
	  } else if (tipo === 16) {
		mx = 24;
		my = 24;
		nx = 12;
		ny = 12;
	  }
	  return { mx, my, nx, ny };
	}

	//Função para calcular coeficiente lambda
	function computeLambda(lx, ly) {
	  let lambda1, lambda2;
	    lambda1 = ly / lx;
		lambda2 = lx / ly;
	  return { lambda1, lambda2 };
	}
	  
	//Função para calcular kx e ky
	function computeK(lambda1, lambda2, tipo) {
	  let kx, ky;
		if (tipo === 1){
		  kx = (Math.pow(lambda1, 4)) / (1 + Math.pow(lambda1, 4));
		  ky = (1) / (1 + Math.pow(lambda1, 4));
		} else if (tipo === 2 || tipo === 4) {
		  kx = (5 * (Math.pow(lambda1, 4))) / (2 + (5 * Math.pow(lambda1, 4)));
		  ky = (2) / (2 + (5 * Math.pow(lambda1, 4)));
		} else if (tipo === 3 || tipo === 5) {
		  kx = (5 * (Math.pow(lambda2, 4))) / (2 + (5 * Math.pow(lambda2, 4)));
		  ky = (2) / (2 + (5 * Math.pow(lambda2, 4)));	
	    } else if (tipo === 6 || tipo === 7 || tipo === 8 || tipo === 9) {
		  kx = (Math.pow(lambda1, 4)) / (1 + Math.pow(lambda1, 4));
		  ky = (1) / (1 + Math.pow(lambda1, 4));
	    } else if (tipo === 10) {
		  kx = (5 * Math.pow(lambda1, 4)) / (1 + 5 * Math.pow(lambda1, 4));
		  ky = (1) / (1 + 5 * Math.pow(lambda1, 4));
	    } else if (tipo === 11) {
		  kx = (5 * Math.pow(lambda2, 4)) / (1 + 5 * Math.pow(lambda2, 4));
		  ky = (1) / (1 + 5 * Math.pow(lambda2, 4));
	    } else if (tipo === 12 || tipo === 14) {
		  kx = (2 * Math.pow(lambda1, 4)) / (1 + 2 * Math.pow(lambda1, 4));
		  ky = (1) / (1 + 2 * Math.pow(lambda1, 4));
	    } else if (tipo === 13 || tipo === 15) {
		  kx = (2 * Math.pow(lambda2, 4)) / (1 + 2 * Math.pow(lambda2, 4));
		  ky = (1) / (1 + 2 * Math.pow(lambda2, 4));
	    } else if (tipo === 16) {
		  kx = Math.pow(lambda1, 4) / (1 + Math.pow(lambda1, 4));
		  ky = 1 / (1 + Math.pow(lambda1, 4));
	  }
	  return { kx, ky };
	}
	  
	//Função para calcular Vx e Vy
	function computeV(tipo, mx, my, kx, ky, lambda1, lambda2) {
      let Vx, Vy;
		if (tipo === 1 || tipo === 2 || tipo === 4 || tipo === 6 || tipo === 7 || tipo === 8 || tipo === 9 || tipo === 10 || tipo === 12 || tipo === 14 || tipo === 16) {
		    Vx = 1 - ((20 * kx) / (3 * mx * Math.pow(lambda1, 2)));
		    Vy = 1 - ((20 * ky * Math.pow(lambda1, 2)) / (3 * my));
		} else if (tipo === 3 || tipo === 5 || tipo === 11 || tipo === 13 || tipo === 15) {
			Vx = 1 - ((20 * kx) / (3 * mx * Math.pow(lambda2, 2)));
		    Vy = 1 - ((20 * ky * Math.pow(lambda2, 2)) / (3 * my));
		}
	  return { Vx, Vy };
	}
	  
	//Função para calcular novos mx e my (Coeficientes de Marcus)
	function computeCoeficientesMlNl(tipo, mx, my, nx, ny, kx, ky, Vx, Vy, lambda1, lambda2) {
      let mlx, mly, nlx, nly;
		if (tipo === 1 || tipo === 2 || tipo === 4 || tipo === 6 || tipo === 7 || tipo === 8 || tipo === 9 || tipo === 10 || tipo === 12 || tipo === 14 || tipo === 16) {
	      mlx = mx / (kx * Vx);
	      mly = my / (ky * Vy * Math.pow(lambda1, 2));
		  nlx = nx / kx;
		  nly = ny / (ky * Math.pow(lambda1, 2));
		} else if (tipo === 3 || tipo === 5 || tipo === 11 || tipo === 13 || tipo === 15) {
		  mlx = my / (ky * Vy);
		  mly = (Math.pow(lambda2, 2) * mx) / (kx * Vx);
		  nlx = ny / ky;
		  nly = nx * Math.pow(lambda2, 2) / kx;
		}
	  return { mlx, mly, nlx, nly };
	}
	  
	//Função para calcular Mx e My (Momentos de Marcus)
	function computeMomentos(q, lx, mlx, mly, nlx, nly) {
      let Mxp, Myp, Mxn, Myn;
	    if (q === 0){
	      return {Mxp: 0, Myp: 0, Mxn: 0, Myn: 0}
	    }
		
		if (mlx === 0){
		  Mxp = 0;
		} else {
	      Mxp = (q * Math.pow(lx, 2)) / (mlx); }
		if (mly === 0) {
		  Myp = 0;
		} else {
		  Myp = (q * Math.pow(lx, 2)) / (mly); }
		if (nlx === 0){
		  Mxn = 0;
		} else {
		  Mxn = - (q * Math.pow(lx, 2)) / (nlx); }
		if (nly === 0){
		  Myn = 0;
		} else {
		  Myn = - (q * Math.pow(lx, 2)) / (nly); }
	  return { Mxp, Myp, Mxn, Myn };
	}
		
	}
	  
    // Função que desenha a laje e faz os cálculos para o método de Czerny
    function computeCzerny() {
		
	  //Desenho da laje
      const cw = canvas2.clientWidth;
      const ch = canvas2.clientHeight;
	  const lx = parseFloat(document.getElementById('lx').value) * scale;
	  const ly = parseFloat(document.getElementById('ly').value) * scale;
      ctx2.clearRect(0, 0, cw, ch);
	  
      // Centraliza o retângulo
      const x = (cw - lx) / 2;
      const y = (ch - ly) / 2;

      // Desenha o retângulo principal
      ctx2.strokeStyle = '#333';
      ctx2.lineWidth = 2;
      ctx2.strokeRect(x, y, lx, ly);
		
	  const offset = 20;
      ctx2.lineWidth = 1;
      ctx2.font = '14px Roboto';
      ctx2.fillStyle = '#007BFF';
      ctx2.textAlign = 'center';
		
	  // Lógica para determinar qual texto exibir em cada cota
	  let textHorizontal;
	  let textVertical;

	  if (lx <= ly) {
    	  textHorizontal = `Lx = ${(lx / scale).toFixed(2)} m`;
    	  textVertical = `Ly = ${(ly / scale).toFixed(2)} m`;
	  } else {
    	  textHorizontal = `Ly = ${(lx / scale).toFixed(2)} m`;
    	  textVertical = `Lx = ${(ly / scale).toFixed(2)} m`;
	  }
		
      // Desenha as cotas
      ctx2.beginPath();
      ctx2.moveTo(x, y - offset);
      ctx2.lineTo(x + lx, y - offset);
      ctx2.stroke();
      drawArrow(ctx2, x, y - offset, x + lx, y - offset);
      drawArrow(ctx2, x + lx, y - offset, x, y - offset);
      ctx2.fillText(textHorizontal, x + lx / 2, y - offset - 10);

      ctx2.beginPath();
      ctx2.moveTo(x - offset, y);
      ctx2.lineTo(x - offset, y + ly);
      ctx2.stroke();
      drawArrow(ctx2, x - offset, y, x - offset, y + ly);
      drawArrow(ctx2, x - offset, y + ly, x - offset, y);
      ctx2.save();
      ctx2.translate(x - offset - 10, y + ly / 2);
      ctx2.rotate(-Math.PI / 2);
      ctx2.fillText(textVertical, 0, 0);
      ctx2.restore();

      // Desenha os engastes (linhas vermelhas)
      ctx2.lineWidth = 5;
      ctx2.strokeStyle = 'red';
      if (document.getElementById('engaste1').checked) {
            ctx2.beginPath();
            ctx2.moveTo(x, y);
            ctx2.lineTo(x, y + ly);
            ctx2.stroke();
      }
      if (document.getElementById('engaste2').checked) {
            ctx2.beginPath();
            ctx2.moveTo(x, y);
            ctx2.lineTo(x + lx, y);
            ctx2.stroke();
      }
      if (document.getElementById('engaste3').checked) {
            ctx2.beginPath();
            ctx2.moveTo(x + lx, y);
            ctx2.lineTo(x + lx, y + ly);
            ctx2.stroke();
      }
      if (document.getElementById('engaste4').checked) {
			ctx2.beginPath();
            ctx2.moveTo(x, y + ly);
            ctx2.lineTo(x + lx, y + ly);
            ctx2.stroke(); 
      }		
	
	  //Tabela de Czerny
	  const epsilons = [1.000, 1.050, 1.100, 1.150, 1.200, 1.250, 1.300, 1.350, 1.400, 1.450, 1.500, 1.550, 1.600, 1.800, 2.000];
		
	  const mx1 =      [27.20, 24.50, 22.40, 20.70, 19.10, 17.80, 16.80, 15.80, 15.00, 14.30, 13.70, 13.20, 12.70, 11.30, 10.40];
	  const my1 =      [27.20, 27.50, 27.90, 28.40, 29.10, 29.90, 30.90, 31.80, 32.80, 33.80, 34.70, 35.40, 36.10, 38.50, 40.30];
	  const Vx1 =      [0.250, 0.262, 0.273, 0.283, 0.292, 0.300, 0.308, 0.315, 0.321, 0.327, 0.333, 0.339, 0.344, 0.361, 0.375];
      const Vy1 =      [0.250, 0.238, 0.227, 0.217, 0.208, 0.200, 0.192, 0.185, 0.179, 0.173, 0.167, 0.161, 0.156, 0.139, 0.125];
		
      const mx2A =     [41.20, 36.50, 31.90, 28.30, 25.90, 23.40, 21.70, 20.10, 18.80, 17.50, 16.60, 15.70, 15.00, 12.80, 11.40];
      const my2A =     [29.40, 29.00, 28.80, 28.80, 28.90, 29.20, 29.70, 30.20, 30.80, 31.60, 32.30, 33.00, 33.60, 36.20, 38.80];
      const ny2A =     [11.90, 11.30, 10.90, 10.40, 10.10,  9.80,  9.60,  9.30,  9.20,  9.00,  8.90,  8.80,  8.70,  8.40,  8.20];
      const Vx2A =     [0.183, 0.193, 0.202, 0.211, 0.220, 0.230, 0.239, 0.248, 0.256, 0.264, 0.272, 0.280, 0.286, 0.310, 0.329];
	  const Vy2A_1 =   [0.402, 0.388, 0.378, 0.366, 0.355, 0.342, 0.331, 0.320, 0.310, 0.300, 0.289, 0.280, 0.272, 0.241, 0.217];
	  const Vy2A_2 =   [0.232, 0.226, 0.218, 0.212, 0.205, 0.198, 0.191, 0.184, 0.179, 0.173, 0.167, 0.161, 0.156, 0.139, 0.125];
		
	  const mx2B =     [31.40, 29.20, 27.30, 25.80, 24.50, 23.40, 22.40, 21.60, 21.00, 20.30, 19.80, 19.40, 19.00, 17.80, 17.10];
      const my2B =     [41.20, 43.20, 45.10, 47.10, 48.80, 50.30, 51.80, 53.20, 54.30, 55.00, 55.60, 56.20, 56.80, 58.60, 59.20];
      const nx2B =     [11.90, 11.30, 10.90, 10.50, 10.20,  9.90,  9.70,  9.40,  9.30,  9.10,  9.00,  8.90,  8.80,  8.40,  8.30];
      const Vx2B_1 =   [0.402, 0.412, 0.422, 0.431, 0.440, 0.447, 0.455, 0.461, 0.468, 0.474, 0.479, 0.484, 0.488, 0.504, 0.517];
	  const Vy2B =     [0.183, 0.175, 0.167, 0.160, 0.153, 0.147, 0.141, 0.136, 0.131, 0.126, 0.122, 0.118, 0.115, 0.102, 0.092];
	  const Vx2B_2 =   [0.232, 0.238, 0.244, 0.249, 0.254, 0.259, 0.263, 0.267, 0.270, 0.274, 0.277, 0.280, 0.282, 0.292, 0.299];
		
	  const mx3 =      [40.20, 38.00, 35.10, 32.20, 30.00, 28.00, 26.50, 25.20, 24.10, 23.10, 22.20, 21.60, 21.00, 19.10, 17.90];
	  const my3 =      [40.20, 41.00, 42.00, 42.90, 44.00, 45.60, 47.60, 49.60, 51.00, 52.10, 53.00, 54.10, 54.80, 57.70, 60.20];
	  const nx3 =      [14.30, 13.30, 12.70, 12.00, 11.50, 11.10, 10.70, 10.30, 10.00,  9.80,  9.60,  9.40,  9.20,  8.70,  8.40];
	  const ny3 =      [14.30, 13.80, 13.60, 13.30, 13.10, 12.90, 12.80, 12.70, 12.60, 12.50, 12.40, 12.30, 12.30, 12.20, 12.20];
	  const Vx3_1 =    [0.317, 0.332, 0.347, 0.359, 0.371, 0.381, 0.391, 0.400, 0.408, 0.416, 0.424, 0.431, 0.437, 0.459, 0.476];
	  const Vy3_1 =    [0.317, 0.302, 0.288, 0.276, 0.264, 0.254, 0.244, 0.235, 0.227, 0.219, 0.211, 0.204, 0.198, 0.176, 0.159];
	  const Vx3_2 =    [0.183, 0.191, 0.198, 0.205, 0.212, 0.218, 0.224, 0.229, 0.234, 0.239, 0.243, 0.247, 0.250, 0.263, 0.274];
	  const Vy3_2 =    [0.183, 0.175, 0.167, 0.160, 0.153, 0.147, 0.141, 0.136, 0.131, 0.126, 0.122, 0.118, 0.115, 0.102, 0.091];
	
      const mx4A =     [63.30, 52.20, 46.10, 39.80, 35.50, 31.50, 28.50, 25.80, 23.70, 22.00, 20.40, 19.00, 19.90, 14.60, 12.50];
      const my4A =     [35.10, 33.70, 32.90, 32.20, 31.70, 31.30, 31.20, 31.20, 31.40, 31.70, 32.10, 32.70, 33.30, 37.10, 42.40];
      const ny4A =     [14.30, 13.40, 12.70, 12.00, 11.50, 11.10, 10.70, 10.30, 10.00,  9.75,  9.50,  9.30,  9.20,  8.70,  8.40];
      const Vx4A =     [0.144, 0.151, 0.159, 0.166, 0.173, 0.180, 0.188, 0.196, 0.203, 0.210, 0.217, 0.225, 0.233, 0.259, 0.280];
      const Vy4A =     [0.356, 0.349, 0.341, 0.334, 0.327, 0.320, 0.312, 0.304, 0.297, 0.290, 0.283, 0.275, 0.267, 0.241, 0.217];
		
      const mx4B =     [35.10, 33.00, 31.70, 30.40, 29.40, 28.50, 27.80, 27.10, 26.60, 26.10, 25.80, 25.40, 25.20, 24.40, 24.10];
      const my4B =     [61.70, 64.50, 67.20, 69.60, 71.50, 72.80, 73.50, 74.10, 74.60, 75.30, 75.80, 76.50, 77.00, 77.00, 77.00];
      const nx4B =     [14.00, 13.80, 13.50, 13.20, 13.00, 12.70, 12.60, 12.40, 12.30, 12.20, 12.20, 12.10, 12.00, 12.00, 12.00];
      const Vx4B =     [0.356, 0.363, 0.369, 0.375, 0.380, 0.385, 0.389, 0.393, 0.397, 0.401, 0.404, 0.407, 0.410, 0.420, 0.428];
      const Vy4B =     [0.144, 0.137, 0.131, 0.125, 0.120, 0.115, 0.111, 0.107, 0.103, 0.099, 0.096, 0.093, 0.090, 0.080, 0.072];

	  const mx5A =     [44.10, 40.50, 37.90, 35.50, 33.80, 32.30, 31.00, 29.90, 29.00, 28.20, 27.60, 27.00, 26.50, 25.10, 24.50];
      const my5A =     [55.90, 57.50, 60.30, 64.20, 66.20, 67.70, 69.00, 70.50, 72.00, 73.40, 75.20, 76.90, 78.70, 86.80, 97.00];
      const nx5A =     [16.20, 15.30, 14.80, 14.20, 13.90, 13.50, 13.20, 12.90, 12.70, 12.60, 12.50, 12.40, 12.30, 12.10, 12.00];
      const ny5A =     [18.30, 17.90, 17.70, 17.60, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50];
	  const Vx5A =     [0.303, 0.313, 0.321, 0.329, 0.336, 0.343, 0.349, 0.354, 0.359, 0.364, 0.369, 0.373, 0.377, 0.391, 0.402];
	  const Vy5A_1 =   [0.250, 0.237, 0.227, 0.217, 0.208, 0.200, 0.192, 0.185, 0.179, 0.173, 0.166, 0.161, 0.156, 0.138, 0.125];
	  const Vy5A_2 =   [0.144, 0.137, 0.131, 0.125, 0.120, 0.114, 0.110, 0.107, 0.103, 0.099, 0.096, 0.093, 0.090, 0.080, 0.071];
		  
	  const mx5B =     [59.50, 51.60, 46.10, 41.40, 37.50, 34.20, 31.80, 29.60, 28.00, 26.40, 25.20, 24.20, 23.30, 20.30, 18.70];
      const my5B =     [44.10, 43.60, 43.70, 44.20, 44.80, 40.50, 46.90, 48.60, 50.30, 52.30, 55.00, 58.20, 61.60, 79.60, 101.0];
      const nx5B =     [18.30, 16.60, 15.40, 14.40, 13.50, 12.70, 12.20, 11.60, 11.20, 10.90, 10.60, 10.30, 10.10,  9.40,  8.80];
      const ny5B =     [16.20, 15.40, 14.80, 14.30, 13.90, 13.50, 13.30, 13.10, 13.00, 12.80, 12.70, 12.60, 12.60, 12.40, 12.30];
	  const Vx5B_1 =   [0.250, 0.263, 0.275, 0.288, 0.301, 0.314, 0.327, 0.339, 0.350, 0.360, 0.370, 0.378, 0.387, 0.416, 0.437];
	  const Vy5B =     [0.304, 0.294, 0.284, 0.274, 0.264, 0.254, 0.244, 0.235, 0.227, 0.219, 0.211, 0.402, 0.198, 0.176, 0.159];
	  const Vx5A_2 =   [0.142, 0.149, 0.157, 0.164, 0.171, 0.178, 0.185, 0.191, 0.196, 0.202, 0.208, 0.214, 0.217, 0.232, 0.245];
		
	  const mx6 =      [56.80, 50.60, 46.10, 42.40, 39.40, 37.00, 34.80, 33.30, 31.90, 30.60, 29.60, 28.80, 28.10, 26.00, 25.00];
      const my6 =      [56.80, 58.20, 60.30, 62.60, 65.80, 69.40, 73.60, 78.40, 83.40, 89.40, 93.50, 96.10, 98.10, 103.3, 105.0];
      const nx6 =      [19.40, 18.20, 17.10, 16.30, 15.50, 14.90, 14.50, 14.00, 13.70, 13.40, 13.20, 13.00, 12.80, 12.30, 12.00];
      const ny6 =      [19.40, 18.80, 18.40, 18.10, 17.90, 17.70, 17.60, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50, 17.50];
	  const Vx6 =      [0.250, 0.262, 0.273, 0.283, 0.292, 0.300, 0.308, 0.315, 0.321, 0.327, 0.333, 0.339, 0.344, 0.361, 0.375];
	  const Vy6 =      [0.250, 0.238, 0.227, 0.217, 0.208, 0.200, 0.192, 0.185, 0.179, 0.173, 0.167, 0.161, 0.156, 0.139, 0.125];
	
	//FUNÇÕES
	//Função para calcular coeficientes m e n
	function computeCoeficientes(tipo, epsilon, lx, ly) {
      let mx, my, nx, ny, epsilon0, epsilon1;
	  
	  const i1 = epsilons.findIndex(e => e > epsilon);
	  const i0 = i1 - 1;
		
	  epsilon0 = epsilons[i0];
      epsilon1 = epsilons[i1];
			
      const index = epsilons.indexOf(epsilon);
	  const pond = (epsilon - epsilon0) / (epsilon1 - epsilon0);
		
	if (epsilon > 2){
		return {mx: 0, my: 0, nx: 0, ny: 0 }
	}
	if (epsilons.includes(epsilon)) {
	  if (tipo === 1) {
		    mx = mx1[index];
		    my = my1[index];
		    nx = 0;
		    ny = 0;
	  } else if (tipo === 2) {
		if (lx <= ly) {
		    mx = mx2B[index];
		    my = my2B[index];
		    nx = nx2B[index];
		    ny = 0;
		} else {
		    mx = mx2A[index];
		    my = my2A[index];
		    nx = 0;
		    ny = ny2A[index];
		}
	  } else if (tipo === 3) {
		if (lx <= ly) {
		    mx = mx2A[index];
		    my = my2A[index];
		    nx = 0;
		    ny = ny2A[index];
		} else {
		    mx = mx2B[index];
		    my = my2B[index];
		    nx = nx2B[index];
		    ny = 0;
		}
	  } else if (tipo === 4) {
		if (lx <= ly) {
		    mx = mx2B[index];
		    my = my2B[index];
		    nx = nx2B[index];
		    ny = 0;
		} else {
		    mx = mx2A[index];
		    my = my2A[index];
		    nx = 0;
		    ny = ny2A[index];
		}
	  } else if (tipo === 5) {
		if (lx <= ly) {
		    mx = mx2A[index];
		    my = my2A[index];
		    nx = 0;
		    ny = ny2A[index];
		} else {
		    mx = mx2B[index];
		    my = my2B[index];
		    nx = nx2B[index];
		    ny = 0;
		}
	  } else if (tipo === 6) {
		    mx = mx3[index];
		    my = my3[index];
		    nx = nx3[index];
		    ny = ny3[index];
	  } else if (tipo === 7) {
		    mx = mx3[index];
		    my = my3[index];
		    nx = nx3[index];
		    ny = ny3[index];
	  } else if (tipo === 8) {
		    mx = mx3[index];
		    my = my3[index];
		    nx = nx3[index];
		    ny = ny3[index];
	  } else if (tipo === 9) {
		    mx = mx3[index];
		    my = my3[index];
		    nx = nx3[index];
		    ny = ny3[index];
	  } else if (tipo === 10) {
		if (lx <= ly) {
		    mx = mx4B[index];
		    my = my4B[index];
		    nx = nx4B[index];
		    ny = 0;
		} else {
		    mx = mx4A[index];
		    my = my4A[index];
		    nx = 0;
		    ny = ny4A[index];
		}
	  } else if (tipo === 11) {
		if (lx <= ly) {
		    mx = mx4A[index];
		    my = my4A[index];
		    nx = 0;
		    ny = ny4A[index];
		} else {
		    mx = mx4B[index];
		    my = my4B[index];
		    nx = nx4B[index];
		    ny = 0;
		}
	  } else if (tipo === 12) {
		if (lx <= ly) {
		    mx = mx5B[index];
		    my = my5B[index];
		    nx = nx5B[index];
		    ny = ny5B[index];
		} else {
		    mx = mx5A[index];
		    my = my5A[index];
		    nx = nx5A[index];
		    ny = ny5A[index];
		} 
	  } else if (tipo === 13) {
		if (lx <= ly) {
		    mx = mx5A[index];
		    my = my5A[index];
		    nx = nx5A[index];
		    ny = ny5A[index];
		} else {
			mx = mx5B[index];
		    my = my5B[index];
		    nx = nx5B[index];
		    ny = ny5B[index];
		}
	  } else if (tipo === 14) {
		if (lx <= ly) {
		    mx = mx5B[index];
		    my = my5B[index];
		    nx = nx5B[index];
		    ny = ny5B[index];
		} else {
		    mx = mx5A[index];
		    my = my5A[index];
		    nx = nx5A[index];
		    ny = ny5A[index];
		} 
	  } else if (tipo === 15) {
		if (lx <= ly) {
		    mx = mx5A[index];
		    my = my5A[index];
		    nx = nx5A[index];
		    ny = ny5A[index];
		} else {
			mx = mx5B[index];
		    my = my5B[index];
		    nx = nx5B[index];
		    ny = ny5B[index];
		}
	  } else if (tipo === 16) {
		    mx = mx6[index];
		    my = my6[index];
		    nx = nx6[index];
		    ny = ny6[index];
	  }
	} else {
		if (tipo === 1) {
		    mx = mx1[i0] + (pond * (mx1[i1] - mx1[i0]));
		    my = my1[i0] + (pond * (my1[i1] - my1[i0]));
		    nx = 0;
		    ny = 0;
	  } else if (tipo === 2) {
		if (lx <= ly) {
		    mx = mx2B[i0] + (pond * (mx2B[i1] - mx2B[i0]));
		    my = my2B[i0] + (pond * (my2B[i1] - my2B[i0]));
		    nx = nx2B[i0] + (pond * (nx2B[i1] - nx2B[i0]));
		    ny = 0;
		} else {
		    mx = mx2A[i0] + (pond * (mx2A[i1] - mx2A[i0]));
		    my = my2A[i0] + (pond * (my2A[i1] - my2A[i0]));
		    nx = 0;
		    ny = ny2A[i0] + (pond * (ny2A[i1] - ny2A[i0]));	
		}
	  } else if (tipo === 3) {
		if (lx <= ly) {
		    mx = mx2A[i0] + (pond * (mx2A[i1] - mx2A[i0]));
		    my = my2A[i0] + (pond * (my2A[i1] - my2A[i0]));
		    nx = 0;
		    ny = ny2A[i0] + (pond * (ny2A[i1] - ny2A[i0]));
		} else {
		    mx = mx2B[i0] + (pond * (mx2B[i1] - mx2B[i0]));
		    my = my2B[i0] + (pond * (my2B[i1] - my2B[i0]));
		    nx = nx2B[i0] + (pond * (nx2B[i1] - nx2B[i0]));
		    ny = 0;
		}
	  } else if (tipo === 4) {
		if (lx <= ly) {
		    mx = mx2B[i0] + (pond * (mx2B[i1] - mx2B[i0]));
		    my = my2B[i0] + (pond * (my2B[i1] - my2B[i0]));
		    nx = nx2B[i0] + (pond * (nx2B[i1] - nx2B[i0]));
		    ny = 0;
		} else {
		    mx = mx2A[i0] + (pond * (mx2A[i1] - mx2A[i0]));
		    my = my2A[i0] + (pond * (my2A[i1] - my2A[i0]));
		    nx = 0;
		    ny = ny2A[i0] + (pond * (ny2A[i1] - ny2A[i0]));	
		}
	  } else if (tipo === 5) {
		if (lx <= ly) {
		    mx = mx2A[i0] + (pond * (mx2A[i1] - mx2A[i0]));
		    my = my2A[i0] + (pond * (my2A[i1] - my2A[i0]));
		    nx = 0;
		    ny = ny2A[i0] + (pond * (ny2A[i1] - ny2A[i0]));
		} else {
		    mx = mx2B[i0] + (pond * (mx2B[i1] - mx2B[i0]));
		    my = my2B[i0] + (pond * (my2B[i1] - my2B[i0]));
		    nx = nx2B[i0] + (pond * (nx2B[i1] - nx2B[i0]));
		    ny = 0;
		}
	  } else if (tipo === 6) {
		  mx = mx3[i0] + (pond * (mx3[i1] - mx3[i0]));
		  my = my3[i0] + (pond * (my3[i1] - my3[i0]));
		  nx = nx3[i0] + (pond * (nx3[i1] - nx3[i0]));
		  ny = ny3[i0] + (pond * (ny3[i1] - ny3[i0]));
	  } else if (tipo === 7) {
		  mx = mx3[i0] + (pond * (mx3[i1] - mx3[i0]));
		  my = my3[i0] + (pond * (my3[i1] - my3[i0]));
		  nx = nx3[i0] + (pond * (nx3[i1] - nx3[i0]));
		  ny = ny3[i0] + (pond * (ny3[i1] - ny3[i0]));
	  } else if (tipo === 8) {
		  mx = mx3[i0] + (pond * (mx3[i1] - mx3[i0]));
		  my = my3[i0] + (pond * (my3[i1] - my3[i0]));
		  nx = nx3[i0] + (pond * (nx3[i1] - nx3[i0]));
		  ny = ny3[i0] + (pond * (ny3[i1] - ny3[i0]));
	  } else if (tipo === 9) {
		  mx = mx3[i0] + (pond * (mx3[i1] - mx3[i0]));
		  my = my3[i0] + (pond * (my3[i1] - my3[i0]));
		  nx = nx3[i0] + (pond * (nx3[i1] - nx3[i0]));
		  ny = ny3[i0] + (pond * (ny3[i1] - ny3[i0]));
	  } else if (tipo === 10) {
		if (lx <= ly) {
		  mx = mx4B[i0] + (pond * (mx4B[i1] - mx4B[i0]));
		  my = my4B[i0] + (pond * (my4B[i1] - my4B[i0]));
		  nx = nx4B[i0] + (pond * (nx4B[i1] - nx4B[i0]));
		  ny = 0;
		} else {
		  mx = mx4A[i0] + (pond * (mx4A[i1] - mx4A[i0]));
		  my = my4A[i0] + (pond * (my4A[i1] - my4A[i0]));
		  nx = 0;
		  ny = ny4A[i0] + (pond * (ny4A[i1] - ny4A[i0]));
		}
	  } else if (tipo === 11) {
		if (lx <= ly) {
		  mx = mx4A[i0] + (pond * (mx4A[i1] - mx4A[i0]));
		  my = my4A[i0] + (pond * (my4A[i1] - my4A[i0]));
		  nx = 0;
		  ny = ny4A[i0] + (pond * (ny4A[i1] - ny4A[i0]));
		} else {
		  mx = mx4B[i0] + (pond * (mx4B[i1] - mx4B[i0]));
		  my = my4B[i0] + (pond * (my4B[i1] - my4B[i0]));
		  nx = nx4B[i0] + (pond * (nx4B[i1] - nx4B[i0]));
		  ny = 0;
		}
	  } else if (tipo === 12) {
		if (lx <= ly) {
		  mx = mx5B[i0] + pond * (mx5B[i1] - mx5B[i0]);
		  my = my5B[i0] + pond * (my5B[i1] - my5B[i0]);
		  nx = nx5B[i0] + pond * (nx5B[i1] - nx5B[i0]);
		  ny = ny5B[i0] + pond * (ny5B[i1] - ny5B[i0]);
		} else {
		  mx = mx5A[i0] + pond * (mx5A[i1] - mx5A[i0]);
		  my = my5A[i0] + pond * (my5A[i1] - my5A[i0]);
		  nx = nx5A[i0] + pond * (nx5A[i1] - nx5A[i0]);
		  ny = ny5A[i0] + pond * (ny5A[i1] - ny5A[i0]);
		}
	  } else if (tipo === 13) {
		if (lx <= ly) {
		  mx = mx5A[i0] + pond * (mx5A[i1] - mx5A[i0]);
		  my = my5A[i0] + pond * (my5A[i1] - my5A[i0]);
		  nx = nx5A[i0] + pond * (nx5A[i1] - nx5A[i0]);
		  ny = ny5A[i0] + pond * (ny5A[i1] - ny5A[i0]);
		} else {
		  mx = mx5B[i0] + pond * (mx5B[i1] - mx5B[i0]);
		  my = my5B[i0] + pond * (my5B[i1] - my5B[i0]);
		  nx = nx5B[i0] + pond * (nx5B[i1] - nx5B[i0]);
		  ny = ny5B[i0] + pond * (ny5B[i1] - ny5B[i0]);
		}
	  } else if (tipo === 14) {
		if (lx <= ly) {
		  mx = mx5B[i0] + pond * (mx5B[i1] - mx5B[i0]);
		  my = my5B[i0] + pond * (my5B[i1] - my5B[i0]);
		  nx = nx5B[i0] + pond * (nx5B[i1] - nx5B[i0]);
		  ny = ny5B[i0] + pond * (ny5B[i1] - ny5B[i0]);
		} else {
		  mx = mx5A[i0] + pond * (mx5A[i1] - mx5A[i0]);
		  my = my5A[i0] + pond * (my5A[i1] - my5A[i0]);
		  nx = nx5A[i0] + pond * (nx5A[i1] - nx5A[i0]);
		  ny = ny5A[i0] + pond * (ny5A[i1] - ny5A[i0]);
		}
	  } else if (tipo === 15) {
		if (lx <= ly) {
		  mx = mx5A[i0] + pond * (mx5A[i1] - mx5A[i0]);
		  my = my5A[i0] + pond * (my5A[i1] - my5A[i0]);
		  nx = nx5A[i0] + pond * (nx5A[i1] - nx5A[i0]);
		  ny = ny5A[i0] + pond * (ny5A[i1] - ny5A[i0]);
		} else {
		  mx = mx5B[i0] + pond * (mx5B[i1] - mx5B[i0]);
		  my = my5B[i0] + pond * (my5B[i1] - my5B[i0]);
		  nx = nx5B[i0] + pond * (nx5B[i1] - nx5B[i0]);
		  ny = ny5B[i0] + pond * (ny5B[i1] - ny5B[i0]);
		}
	  } else if (tipo === 16) {
		  mx = mx6[i0] + pond * (mx6[i1] - mx6[i0]);
		  my = my6[i0] + pond * (my6[i1] - my6[i0]);
		  nx = nx6[i0] + pond * (nx6[i1] - nx6[i0]);
		  ny = ny6[i0] + pond * (ny6[i1] - ny6[i0]);
	  }
	}
        return { mx, my, nx, ny };
	}
	
	// Função para calcular coeficiente epsilon
	function computeEpsilon(lx, ly) {
	  let epsilon;
	      epsilon = ly / lx;
	  return { epsilon };
	}
	  
	// Função para calcular Mx e My (Momentos de Czerny)
	function computeMomentos(q, lx, mx, my, nx, ny) {
      let Mxp, Myp, Mxn, Myn;
		if (q === 0){
			return {Mxp: 0, Myp: 0, Mxn: 0, Myn: 0}
		}
		if (mx === 0){
		  Mxp = 0;
		} else {
	      Mxp = (q * Math.pow(lx, 2)) / (mx); }
		if (my === 0) {
		  Myp = 0;
		} else {
		  Myp = (q * Math.pow(lx, 2)) / (my); }
		if (nx === 0){
		  Mxn = 0;
		} else {
		  Mxn = - (q * Math.pow(lx, 2)) / (nx); }
		if (ny ===0){
		  Myn = 0;
		} else {
		  Myn = - (q * Math.pow(lx, 2)) / (ny); }
	  return { Mxp, Myp, Mxn, Myn };
	}
		
    //CÁLCULOS
    const tipo_m = getTipoLaje();
    const lx_m = Math.min(parseFloat(document.getElementById('lx').value), parseFloat(document.getElementById('ly').value));
    const ly_m = Math.max(parseFloat(document.getElementById('lx').value), parseFloat(document.getElementById('ly').value));
    const q_m = parseFloat(document.getElementById('q').value);
	const epsilon = computeEpsilon(lx_m, ly_m);
	const Coeficientes = computeCoeficientes(tipo_m, epsilon.epsilon, lx, ly);
	const Momentos = computeMomentos(q_m, lx_m, Coeficientes.mx, Coeficientes.my, Coeficientes.nx, Coeficientes.ny);

      // Resultados (Coeficiente mx, my, nx, e ny)
      document.getElementById('mxCzernyoutput').innerText =
        `${Coeficientes.mx.toFixed(3)}`;
	  document.getElementById('myCzernyoutput').innerText =
        `${Coeficientes.my.toFixed(3)}`;
      document.getElementById('nxCzernyoutput').innerText =
        `${Coeficientes.nx.toFixed(3)}`;
	  document.getElementById('nyCzernyoutput').innerText =
        `${Coeficientes.ny.toFixed(3)}`;

      // Resultados (Lambda)
      document.getElementById('epsilonoutput').innerText =
        `${epsilon.epsilon.toFixed(2)}`;
		
	  // Resultados (Momentos Solicitantes)
      document.getElementById('MxpositivoCzernyoutput').innerText =
        `${Momentos.Mxp.toFixed(3)} kN.m`;
      document.getElementById('MypositivoCzernyoutput').innerText =
        `${Momentos.Myp.toFixed(3)} kN.m`;
      document.getElementById('MxnegativoCzernyoutput').innerText =
        `${Momentos.Mxn.toFixed(3)} kN.m`;
      document.getElementById('MynegativoCzernyoutput').innerText =
        `${Momentos.Myn.toFixed(3)} kN.m`;	
	}
	
	// Função que desenha a laje e faz os cálculos para o método das Linhas de Ruptura
	function computeCharneiras() {
		
      //Desenho da laje
      const cw = canvas3.clientWidth;
      const ch = canvas3.clientHeight;
      const lx = parseFloat(document.getElementById('lx').value) * scale;
      const ly = parseFloat(document.getElementById('ly').value) * scale;
      ctx3.clearRect(0, 0, cw, ch);
		
      // Centraliza o retângulo
      const x = (cw - lx) / 2;
      const y = (ch - ly) / 2;

      // Desenha o retângulo principal
      ctx3.strokeStyle = '#333';
      ctx3.lineWidth = 2;
      ctx3.strokeRect(x, y, lx, ly);

      // Desenha as cotas
      const offset = 20;
      ctx3.lineWidth = 1;
      ctx3.beginPath();
      ctx3.moveTo(x, y - offset);
      ctx3.lineTo(x + lx, y - offset);
      ctx3.stroke();
      drawArrow(ctx3, x, y - offset, x + lx, y - offset);
      drawArrow(ctx3, x + lx, y - offset, x, y - offset);
      ctx3.font = '14px Roboto';
      ctx3.fillStyle = '#007BFF';
      ctx3.textAlign = 'center';
      ctx3.fillText(`Lx = ${(lx / scale).toFixed(2)} m`, x + lx / 2, y - offset - 10);

      ctx3.beginPath();
      ctx3.moveTo(x - offset, y);
      ctx3.lineTo(x - offset, y + ly);
      ctx3.stroke();
      drawArrow(ctx3, x - offset, y, x - offset, y + ly);
      drawArrow(ctx3, x - offset, y + ly, x - offset, y);
      ctx3.save();
      ctx3.translate(x - offset - 10, y + ly / 2);
      ctx3.rotate(-Math.PI / 2);
      ctx3.textAlign = 'center';
      ctx3.fillText(`Ly = ${(ly / scale).toFixed(2)} m`, 0, 0);
      ctx3.restore();

      // Desenha os engastes (linhas vermelhas)
      ctx3.lineWidth = 3;
      ctx3.strokeStyle = 'red';
      if (document.getElementById('engaste1').checked) {
        ctx3.beginPath();
        ctx3.moveTo(x, y);
        ctx3.lineTo(x, y + ly);
        ctx3.stroke();
      }
      if (document.getElementById('engaste2').checked) {
        ctx3.beginPath();
        ctx3.moveTo(x, y);
        ctx3.lineTo(x + lx, y);
        ctx3.stroke();
      }
      if (document.getElementById('engaste3').checked) {
        ctx3.beginPath();
        ctx3.moveTo(x + lx, y);
        ctx3.lineTo(x + lx, y + ly);
        ctx3.stroke();
      }
      if (document.getElementById('engaste4').checked) {
        ctx3.beginPath();
        ctx3.moveTo(x, y + ly);
        ctx3.lineTo(x + lx, y + ly);
        ctx3.stroke();
      }

      // Chama o tipo de laje
      const tipo = getTipoLaje();
      document.getElementById('tipoLajeOutput').innerText = `${tipo}`;
		
      // Chama a função de desenho interna conforme o tipo
      if (tipo === 1) {
        drawLajeTipo1(x, y, lx, ly);
      } else if (tipo === 2) {
        drawLajeTipo2(x, y, lx, ly);
      } else if (tipo === 3) {
        drawLajeTipo3(x, y, lx, ly);
      } else if (tipo === 4) {
        drawLajeTipo4(x, y, lx, ly);
      } else if (tipo === 5) {
        drawLajeTipo5(x, y, lx, ly);
      } else if (tipo === 6) {
        drawLajeTipo6(x, y, lx, ly);
      } else if (tipo === 7) {
        drawLajeTipo7(x, y, lx, ly);
      } else if (tipo === 8) {
        drawLajeTipo8(x, y, lx, ly);
      } else if (tipo === 9) {
        drawLajeTipo9(x, y, lx, ly);
      } else if (tipo === 10) {
        drawLajeTipo10(x, y, lx, ly);
      } else if (tipo === 11) {
        drawLajeTipo11(x, y, lx, ly);
      } else if (tipo === 12) {
        drawLajeTipo12(x, y, lx, ly);
      } else if (tipo === 13) {
        drawLajeTipo13(x, y, lx, ly);
      } else if (tipo === 14) {
        drawLajeTipo14(x, y, lx, ly);
      } else if (tipo === 15) {
        drawLajeTipo15(x, y, lx, ly);
      } else if (tipo === 16) {
        drawLajeTipo16(x, y, lx, ly);
      }
	
      document.getElementById('tipoLajeOutput').innerText = `${tipo}`;
    // Chama a função que calcula os resultados
    const tipo_m = getTipoLaje();
    const lx_m = parseFloat(document.getElementById('lx').value);
    const ly_m = parseFloat(document.getElementById('ly').value);
    const q_m = parseFloat(document.getElementById('q').value);
	const K = computeK(lx_m, ly_m);
    const areas = computeAreas(tipo_m, lx_m, ly_m);
    const reacoes = computeReacoes(lx_m, ly_m, q_m, areas.area1, areas.area2, areas.area3, areas.area4);
    const forcas = computeForcas(q_m, areas.area1, areas.area2, areas.area3, areas.area4);
	const forcasK = computeForcasK(forcas.F1, forcas.F2, forcas.F3, forcas.F4, K.RK);
    const CGs = computeCG(tipo_m, lx_m, ly_m);
	const CGKs = computeCGK(K.lxK, K.lyK, CGs.CG1, CGs.CG2, CGs.CG3, CGs.CG4, K.RK);
    const Lps = computeLp(tipo_m, lx_m, ly_m);
	const LpKs = computeLpK(K.lxK, K.lyK, Lps.Lp1, Lps.Lp2, Lps.Lp3, Lps.Lp4, K.RK);
    const deltas = computeDeltas(CGKs.CG1K, CGKs.CG2K, CGKs.CG3K, CGKs.CG4K, LpKs.Lp1K, LpKs.Lp2K, LpKs.Lp3K, LpKs.Lp4K);
    const thetas = computeThetas(LpKs.Lp1K, LpKs.Lp2K, LpKs.Lp3K, LpKs.Lp4K);
    const We = computeWe(forcasK.F1K, forcasK.F2K, forcasK.F3K, forcasK.F4K, deltas.delta1, deltas.delta2, deltas.delta3, deltas.delta4);
    const Wi = computeWi(tipo_m, K.lxK, K.lyK, thetas.theta1, thetas.theta2, thetas.theta3, thetas.theta4);
    const Mp = computeMp(We.We, Wi.Wi);
	const Msd = computeMsd(K.lxK, K.lyK, Mp.Mp, K.K);
	const momentos = computeMomentos(tipo_m, Msd.Mx1, Msd.Mx2, Msd.My1, Msd.My2);
	const coeficientes = computeCoeficientes(q_m, lx_m, momentos.Mxp, momentos.Myp, momentos.Mxn, momentos.Myn);


      // Resultados (Coeficientes)
	  document.getElementById('mxRupturaoutput').innerText =
        `${coeficientes.mx.toFixed(3)}`;
	  document.getElementById('myRupturaoutput').innerText =
        `${coeficientes.my.toFixed(3)}`;
	  document.getElementById('nxRupturaoutput').innerText =
        `${coeficientes.nx.toFixed(3)}`;
	  document.getElementById('nyRupturaoutput').innerText =
        `${coeficientes.ny.toFixed(3)}`;
		
	  // Resultados (Momentos Solicitantes)
	  document.getElementById('MxpositivoRupturaoutput').innerText =
        `${momentos.Mxp.toFixed(3)} kN.m`;
	  document.getElementById('MypositivoRupturaoutput').innerText =
        `${momentos.Myp.toFixed(3)} kN.m`;
      document.getElementById('MxnegativoRupturaoutput').innerText =
        `${momentos.Mxn.toFixed(3)} kN.m`;
      document.getElementById('MynegativoRupturaoutput').innerText =
        `${momentos.Myn.toFixed(3)} kN.m`;



    // Números 1 a 4 dentro do retângulo:
    ctx3.fillStyle = '#000';
    ctx3.font = 'regular 12px Roboto';
    ctx3.textAlign = 'center';
    ctx3.textBaseline = 'middle';

    function drawNumber(num, px, py) {
      const canvasX = x + px * lx;
      const canvasY = y + ly - py * ly; // Inverter o Y pois a origem é no canto superior
      ctx3.fillText(num, canvasX, canvasY);
    }

    drawNumber(1, 0.1, 0.5);
    drawNumber(2, 0.5, 0.9);
    drawNumber(3, 0.9, 0.5);
    drawNumber(4, 0.5, 0.1);
    

	//Função para calcular coeficiente de correção K
	function computeK(lx, ly) {
	  let lambda, K, RK, lxK, lyK;
	  if(lx <= ly) {
	    lambda = ly / lx;
		K = (1) / (3 * (lambda * lambda) - 2);
		RK = Math.sqrt(K);
		lxK = lx;
		lyK = ly / RK;
	  } else {
	    lambda = lx / ly;
		K = (1) / (3 * (lambda * lambda) - 2);
		RK = Math.sqrt(K);
		lxK = lx / RK;
		lyK = ly;
	  }
	  return { lambda, K, RK, lxK, lyK };
	}
	  
    // Funções para calcular as áreas
    function computeAreas(tipo, lx, ly) {
      let area1, area2, area3, area4;
      if (tipo === 1) {
        if (lx <= ly) {
          area1 = (0.50 * lx) * (ly - 0.50 * lx);
          area2 = (0.25 * lx) * lx;
          area3 = (0.50 * lx) * (ly - 0.50 * lx);
          area4 = (0.25 * lx) * lx;
        } else {
          area1 = (0.25 * ly) * ly;
          area2 = (0.50 * ly) * (lx - 0.50 * ly);
          area3 = (0.25 * ly) * ly;
          area4 = (0.50 * ly) * (lx - 0.50 * ly);
        }
      } else if (tipo === 2) {
          if (lx <= 1.366025 * ly) {
          area1 = (0.633975 * lx) * (ly - 0.366025 * lx);
          area2 = (0.500000 * lx) * (0.366025 * lx);
          area3 = (0.366025 * lx) * (ly - 0.366025 * lx);
          area4 = (0.500000 * lx) * (0.366025 * lx);
        } else {
          area1 = ly * (ly * 0.25 * Math.sqrt(3));
          area2 = (0.50 * ly) * (lx - 0.25 *ly * (1 + Math.sqrt(3)));
          area3 = (0.25 * ly) * ly;
          area4 = (0.50 * ly) * (lx - 0.25 *ly * (1 + Math.sqrt(3)));
        }
      } else if (tipo === 3) {
          if (lx <= 0.732051 * ly) {
          area1 = (0.50 * lx) * (ly - 0.25 *lx * (1 + Math.sqrt(3)));
          area2 = lx * (lx * 0.25 * Math.sqrt(3));
          area3 = (0.50 * lx) * (ly - 0.25 *lx * (1 + Math.sqrt(3)));
          area4 = (0.25 * lx) * lx;
        } else {
          area1 = (0.500000 * ly) * (0.366025 * ly);
          area2 = (0.633975 * ly) * (lx - 0.366025 * ly);
          area3 = (0.500000 * ly) * (0.366025 * ly);
          area4 = (0.366025 * ly) * (lx - 0.366025 * ly);
        }
      } else if (tipo === 4) {
          if (lx <= 1.366025 * ly) {
          area1 = (0.366025 * lx) * (ly - 0.366025 * lx);
          area2 = (0.5 * 0.366025 * lx) * lx;
          area3 = (ly - 0.366025 * lx)*(lx - 0.366025 * lx);
          area4 = (0.5 * 0.366025 * lx) * lx;
        } else {
          area1 = 0.25 * ly * ly;
          area2 = 0.5 * ly * (lx - 0.25 *ly * (1 + Math.sqrt(3)));
          area3 = ly * (ly * 0.25 * Math.sqrt(3));
          area4 = 0.5 * ly * (lx - 0.25 *ly * (1 + Math.sqrt(3)));
        }
      } else if (tipo === 5) {
          if (lx <= 0.732051 * ly) {
          area1 = (0.50 * lx) * (ly - 0.25 * lx * (1 + Math.sqrt(3)));
          area2 = (0.25 * lx) * lx;
          area3 = (0.50 * lx) * (ly - 0.25 * lx * (1 + Math.sqrt(3)));
          area4 = lx * (lx * 0.25 * Math.sqrt(3));
        } else {
          area1 = (0.500000 * ly) * (0.366025 * ly);
          area2 = (0.366025 * ly) * (lx - 0.366025 * ly);
          area3 = (0.500000 * ly) * (0.366025 * ly);
          area4 = (0.633975 * ly) * (lx - 0.366025 * ly);
        }
      } else if (tipo === 6) {
          if (lx <= ly) {
          area1 = (0.633975 * lx) * (ly - 0.5 * lx);
          area2 = (0.633975 * lx) * (0.5 * lx);
          area3 = (0.366025 * lx) * (ly - 0.5 * lx);
          area4 = (0.366025 * lx) * (0.5 * lx);
        } else {
          area1 = (0.633975 * ly) * (0.5 * ly);
          area2 = (0.633975 * ly) * (lx - 0.5 * ly);
          area3 = (0.366025 * ly) * (0.5 * ly);
          area4 = (0.366025 * ly) * (lx - 0.5 * ly);
        }
      } else if (tipo === 7) {
          if (lx <= ly) {
          area1 = (0.366025 * lx) * (ly - 0.5 * lx);
          area2 = (0.633975 * lx) * (0.5 * lx);
          area3 = (0.633975 * lx) * (ly - 0.5 * lx);
          area4 = (0.366025 * lx) * (0.5 * lx);
        } else {
          area1 = (0.366025 * ly) * (0.5 * ly);
          area2 = (0.633975 * ly) * (lx - 0.5 * ly);
          area3 = (0.633975 * ly) * (0.5 * ly);
          area4 = (0.366025 * ly) * (lx - 0.5 * ly);
        }
      } else if (tipo === 8) {
          if (lx <= ly) {
          area1 = (0.366025 * lx) * (ly - 0.5 * lx);
          area2 = (0.366025 * lx) * (0.5 * lx);
          area3 = (0.633975 * lx) * (ly - 0.5 * lx);
          area4 = (0.633975 * lx) * (0.5 * lx);
        } else {
          area1 = (0.366025 * ly) * (0.5 * ly);
          area2 = (0.366025 * ly) * (lx - 0.5 * ly);
          area3 = (0.633975 * ly) * (0.5 * ly);
          area4 = (0.633975 * ly) * (lx - 0.5 * ly);
        }
      } else if (tipo === 9) {
          if (lx <= ly) {
          area1 = (0.633975 * lx) * (ly - 0.5 * lx);
          area2 = (0.366025 * lx) * (0.5 * lx);
          area3 = (0.366025 * lx) * (ly - 0.5 * lx);
          area4 = (0.633975 * lx) * (0.5 * lx);
        } else {
          area1 = (0.633975 * ly) * (0.5 * ly);
          area2 = (0.366025 * ly) * (lx - 0.5 * ly);
          area3 = (0.366025 * ly) * (0.5 * ly);
          area4 = (0.633975 * ly) * (lx - 0.5 * ly);
        }
      } else if (tipo === 10) {
          if (lx <= 1.732051 * ly) {
          area1 = (0.5 * lx) * (ly - 0.288675 * lx);
          area2 = (0.5 * lx) * (0.288675 * lx);
          area3 = (0.5 * lx) * (ly - 0.288675 * lx);
          area4 = (0.5 * lx) * (0.288675 * lx);
        } else {
          area1 = (0.25 * ly) * (Math.sqrt(3) * ly);
          area2 = (0.50 * ly) * (lx - 0.5 * Math.sqrt(3) * ly);
          area3 = (0.25 * ly) * (Math.sqrt(3) * ly);
          area4 = (0.50 * ly) * (lx - 0.5 * Math.sqrt(3) * ly);
        }
      } else if (tipo === 11) {
          if (lx <= 0.577350 * ly) {
          area1 = (0.50 * lx) * (ly - 0.5 * Math.sqrt(3) * lx);
          area2 = (0.25 * lx) * (Math.sqrt(3) * lx);
          area3 = (0.50 * lx) * (ly - 0.5 * Math.sqrt(3) * lx);
          area4 = (0.25 * lx) * (Math.sqrt(3) * lx);
        } else {
          area1 = (0.50 * ly) * (0.288675 * ly);
          area2 = (0.50 * ly) * (lx - 0.288675 * ly);
          area3 = (0.25 * ly) * (0.288675 * ly);
          area4 = (0.50 * ly) * (lx - 0.288675 * ly);
        }
      } else if (tipo === 12) {
          if (lx <= 1.267949 * ly) {
          area1 = (0.25 * lx) * (2 * ly - 0.788675 * lx);
          area2 = (0.25 * lx) * lx;
          area3 = (0.25 * lx) * (2 * ly - 0.788675 * lx);
          area4 = (0.50 * lx) * (0.288675 * lx);
        } else {
          area1 = (0.633975 * ly) * (0.5 * ly);
          area2 = (0.633975 * ly) * (lx - 0.633975 * ly);
          area3 = (0.633975 * ly) * (0.5 * ly);
          area4 = (0.366025 * ly) * (lx - 0.633975 * ly);
        }
      } else if (tipo === 13) {
          if (lx <= 0.788675 * ly) {
          area1 = (0.366025 * lx) * (ly - 0.633975 * lx);
          area2 = (0.633975 * lx) * (0.5 * lx);
          area3 = (0.633975 * lx) * (ly - 0.633975 * lx);
          area4 = (0.633975 * lx) * (0.5 * lx);
        } else {
          area1 = (0.50 * ly) * (0.288675 * ly);
          area2 = (0.25 * ly) * (2 * lx - 0.788675 * ly);
          area3 = (0.25 * ly) * ly;
          area4 = (0.25 * ly) * (2 * lx - 0.788675 * ly);
        }
      } else if (tipo === 14) {
          if (lx <= 1.267949 * ly) {
          area1 = (0.25 * lx) * (2 * ly - 0.788675 * lx);
          area2 = (0.50 * lx) * (0.288675 * lx);
          area3 = (0.25 * lx) * (2 * ly - 0.788675 * lx);
          area4 = (0.25 * lx) * lx;
        } else {
          area1 = (0.633975 * ly) * (0.5 * ly);
          area2 = (0.366025 * ly) * (lx - 0.633975 * ly);
          area3 = (0.633975 * ly) * (0.5 * ly);
          area4 = (0.633975 * ly) * (lx - 0.633975 * ly);
        }
      } else if (tipo === 15) {
           if (lx <= 0.788675 * ly) {
          area1 = (0.633975 * lx) * (ly - 0.633975 * lx);
          area2 = (0.633975 * lx) * (0.5 * lx);
          area3 = (0.366025 * lx) * (ly - 0.633975 * lx);
          area4 = (0.633975 * lx) * (0.5 * lx);
        } else {
          area1 = (0.25 * ly) * ly;
          area2 = (0.25 * ly) * (2 * lx - 0.788675 * ly);
          area3 = (0.50 * ly) * (0.288675 * ly);
          area4 = (0.25 * ly) * (2 * lx - 0.788675 * ly);
        }
      } else if (tipo === 16) {
           if (lx <= ly) {
          area1 = (0.50 * lx) * (ly - 0.50 * lx);
          area2 = (0.25 * lx) * lx;
          area3 = (0.50 * lx) * (ly - 0.50 * lx);
          area4 = (0.25 * lx) * lx;
        } else {
          area1 = (0.25 * ly) * ly;
          area2 = (0.50 * ly) * (lx - 0.50 * ly);
          area3 = (0.25 * ly) * ly;
          area4 = (0.50 * ly) * (lx - 0.50 * ly);
        }
      }
      return { area1, area2, area3, area4 };
    }

    // Função para calcular as reações de apoio
    function computeReacoes(lx, ly, q, area1, area2, area3, area4) {
      let apoio1, apoio2, apoio3, apoio4;
        apoio1 = q * area1 / ly;
        apoio2 = q * area2 / lx;
        apoio3 = q * area3 / ly;
        apoio4 = q * area4 / lx;
      return { apoio1, apoio2, apoio3, apoio4 };
    }

    // Função para calcular as forças resultantes
    function computeForcas(q, area1, area2, area3, area4) {
      let F1, F2, F3, F4;
        F1 = q * area1;
        F2 = q * area2;
        F3 = q * area3;
        F4 = q * area4;
      return { F1, F2, F3, F4 };
    }
	  
	// Função para calcular as forças resultantes corrigidas por K
	function computeForcasK(F1, F2, F3, F4, RK) {
	  let F1K, F2K, F3K, F4K;
		F1K = F1 / RK;
        F2K = F2 / RK;
        F3K = F3 / RK;
        F4K = F4 / RK;
	  return { F1K, F2K, F3K, F4K };
	}

    // Função para calcular os centros geométricos de cada região da laje
    function computeCG(tipo, lx, ly) {
      let CG1, CG2, CG3, CG4;
      if (tipo === 1) {
        if (lx <= ly) {
          CG1 = (lx / 6) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG2 = (lx / 6);
          CG3 = (lx / 6) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG4 = (lx / 6);
        } else {
          CG1 = (ly / 6);
          CG2 = (ly / 6) * ((3 * lx - 2 * ly) / (2 * lx - ly));
          CG3 = (ly / 6);
          CG4 = (ly / 6) * ((3 * lx - 2 * ly) / (2 * lx - ly));
        }
      } else if (tipo === 2) {
        if (lx <= 1.366025 * ly) {
          CG1 = ((0.633975 * lx) / 3) * ((3 * ly - 1.464102 * lx) / (2 * ly - 0.732051 * lx));
          CG2 = ((0.366025 * lx) / 3);
          CG3 = ((0.366025 * lx) / 3) * ((3 * ly - 1.464102 * lx) / (2 * ly - 0.732051 * lx));
          CG4 = ((0.366025 * lx) / 3);
        } else {
          CG1 = (ly / 6) * (Math.sqrt(3));
          CG2 = (ly / 6) * ((3 * lx - (Math.sqrt(3) + 1) * ly) / (2 * lx - 0.5 * (Math.sqrt(3) + 1) * ly));
          CG3 = (ly / 6);
          CG4 = (ly / 6) * ((3 * lx - (Math.sqrt(3) + 1) * ly) / (2 * lx - 0.5 * (Math.sqrt(3) + 1) * ly));
        }
      } else if (tipo === 3) {
        if (lx <= 0.732051 * ly) {
          CG1 = (lx / 6) * ((3 * ly - (Math.sqrt(3) + 1) * lx) / (2 * ly - 0.5 * (Math.sqrt(3) + 1) * lx));
          CG2 = (lx / 6) * (Math.sqrt(3));
          CG3 = (lx / 6) * ((3 * ly - (Math.sqrt(3) + 1) * lx) / (2 * ly - 0.5 * (Math.sqrt(3) + 1) * lx));
          CG4 = (lx / 6);
        } else {
          CG1 = ((0.366025 * ly) / 3);
          CG2 = ((0.633975 * ly) / 3) * ((3 * lx - 1.464102 * ly) / (2 * lx - 0.732051 * ly));
          CG3 = ((0.366025 * ly) / 3);
          CG4 = ((0.366025 * ly) / 3) * ((3 * lx - 1.464102 * ly) / (2 * lx - 0.732051 * ly));
        }
      } else if (tipo === 4) {
        if (lx <= 1.366025 * ly) {
          CG1 = ((0.366025 * lx) / 3) * ((3 * ly - 1.464102 * lx) / (2 * ly - 0.732051 * lx));
          CG2 = ((0.366025 * lx) / 3);
          CG3 = ((0.633975 * lx) / 3) * ((3 * ly - 1.464102 * lx) / (2 * ly - 0.732051 * lx));
          CG4 = ((0.366025 * lx) / 3);
        } else {
          CG1 = (ly / 6);
          CG2 = (ly / 6) * ((3 * lx - (Math.sqrt(3) + 1) * ly) / (2 * lx - 0.5 * (Math.sqrt(3) + 1) * ly));
          CG3 = (ly / 6) * (Math.sqrt(3));
          CG4 = (ly / 6) * ((3 * lx - (Math.sqrt(3) + 1) * ly) / (2 * lx - 0.5 * (Math.sqrt(3) + 1) * ly));
        }
      } else if (tipo === 5) {
        if (lx <= 0.732051 * ly) {
          CG1 = (lx / 6) * ((3 * ly - (Math.sqrt(3) + 1) * lx) / (2 * ly - 0.5 * (Math.sqrt(3) + 1) * lx));
          CG2 = (lx / 6);
          CG3 = (lx / 6) * ((3 * ly - (Math.sqrt(3) + 1) * lx) / (2 * ly - 0.5 * (Math.sqrt(3) + 1) * lx));
          CG4 = (lx / 6) * (Math.sqrt(3));
        } else {
          CG1 = ((0.366025 * ly) / 3);
          CG2 = ((0.366025 * ly) / 3) * ((3 * lx - 1.464102 * ly) / (2 * lx - 0.732051 * ly));
          CG3 = ((0.366025 * ly) / 3);
          CG4 = ((0.633975 * ly) / 3) * ((3 * lx - 1.464102 * ly) / (2 * lx - 0.732051 * ly));
        }
      } else if (tipo === 6) {
        if (lx <= ly) {
          CG1 = ((0.633975 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG2 = ((0.633975 * lx) / 3);
          CG3 = ((0.366025 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG4 = ((0.366025 * lx) / 3);
        } else {
          CG1 = ((0.633975 * ly) / 3);
          CG2 = ((0.633975 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
          CG3 = ((0.366025 * ly) / 3);
          CG4 = ((0.366025 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
        }
      } else if (tipo === 7) {
        if (lx <= ly) {
          CG1 = ((0.366025 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG2 = ((0.633975 * lx) / 3);
          CG3 = ((0.633975 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG4 = ((0.366025 * lx) / 3);
        } else {
          CG1 = ((0.366025 * ly) / 3);
          CG2 = ((0.633975 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
          CG3 = ((0.633975 * ly) / 3);
          CG4 = ((0.366025 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
        }
      } else if (tipo === 8) {
        if (lx <= ly) {
          CG1 = ((0.366025 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG2 = ((0.366025 * lx) / 3);
          CG3 = ((0.633975 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG4 = ((0.633975 * lx) / 3);
        } else {
          CG1 = ((0.366025 * ly) / 3);
          CG2 = ((0.366025 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
          CG3 = ((0.633975 * ly) / 3);
          CG4 = ((0.633975 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
        }
      } else if (tipo === 9) {
        if (lx <= ly) {
          CG1 = ((0.633975 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG2 = ((0.366025 * lx) / 3);
          CG3 = ((0.366025 * lx) / 3) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG4 = ((0.633975 * lx) / 3);
        } else {
          CG1 = ((0.633975 * ly) / 3);
          CG2 = ((0.366025 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
          CG3 = ((0.366025 * ly) / 3);
          CG4 = ((0.633975 * ly) / 3) * ((3 * lx - 2 * ly) / (2 * lx - ly));
        }
      } else if (tipo === 10) {
        if (lx <= 1.732051 * ly) {
          CG1 = (lx / 6) * ((3 * ly - 1.154701 * lx) / (2 * ly - 0.577350 * lx));
          CG2 = ((0.288675 * lx) / 3);
          CG3 = (lx / 6) * ((3 * ly - 1.154701 * lx) / (2 * ly - 0.577350 * lx));
          CG4 = ((0.288675 * lx) / 3);
        } else {
          CG1 = (ly / 6) * (Math.sqrt(3));
          CG2 = (ly / 6) * ((3 * lx - 2 * Math.sqrt(3) * ly) / (2 * lx - Math.sqrt(3) * ly));
          CG3 = (ly / 6) * (Math.sqrt(3));
          CG4 = (ly / 6) * ((3 * lx - 2 * Math.sqrt(3) * ly) / (2 * lx - Math.sqrt(3) * ly));
        }
      } else if (tipo === 11) {
        if (lx <= 0.577350 * ly) {
          CG1 = (lx / 6) * ((3 * ly - 2 * Math.sqrt(3) * lx) / (2 * ly - Math.sqrt(3) * lx));
          CG2 = (lx / 6 ) * (Math.sqrt(3));
          CG3 = (lx / 6) * ((3 * ly - 2 * Math.sqrt(3) * lx) / (2 * ly - Math.sqrt(3) * lx));
          CG4 = (lx / 6 ) * (Math.sqrt(3));
        } else {
          CG1 = ((0.288675 * ly) / 3);
          CG2 = (ly / 6) * ((3 * lx - 1.154701 * ly) / (2 * lx - 0.577350 * ly));
          CG3 = ((0.288675 * ly) / 3);
          CG4 = (ly / 6) * ((3 * lx - 1.154701 * ly) / (2 * lx - 0.577350 * ly));
        }
      } else if (tipo === 12) {
        if (lx <= 1.267949 * ly) {
          CG1 = (lx / 6) * ((3 * ly - 1.577350 * lx) / (2 * ly - 0.788675 * lx));
          CG2 = (lx / 6);
          CG3 = (lx / 6) * ((3 * ly - 1.577350 * lx) / (2 * ly - 0.788675 * lx));
          CG4 = ((0.288675 * lx) / 3);
        } else {
          CG1 = ((0.633975 * ly) / 3);
          CG2 = ((0.633975 * ly) / 3) * ((3 * lx - 2.535898 * ly) / (2 * lx - 1.267949 * ly));
          CG3 = ((0.633975 * ly) / 3);
          CG4 = ((0.366025 * ly) / 3) * ((3 * lx - 2.535898 * ly) / (2 * lx - 1.267949 * ly));
        }
      } else if (tipo === 13) {
        if (lx <= 0.788675 * ly) {
          CG1 = ((0.366025 * lx) / 3) * ((3 * ly - 2.535898 * lx) / (2 * ly - 1.267949 * lx));
          CG2 = ((0.633975 * lx) / 3);
          CG3 = ((0.633975 * lx) / 3) * ((3 * ly - 2.535898 * lx) / (2 * ly - 1.267949 * lx));
          CG4 = ((0.633975 * lx) / 3);
        } else {
          CG1 = ((0.288675 * ly) / 3);
          CG2 = (ly / 6) * ((3 * lx - 1.577350 * ly) / (2 * lx - 0.788675 * ly));
          CG3 = (ly / 6);
          CG4 = (ly / 6) * ((3 * lx - 1.577350 * ly) / (2 * lx - 0.788675 * ly));
        }
      } else if (tipo === 14) {
        if (lx <= 1.267949 * ly) {
          CG1 = (lx / 6) * ((3 * ly - 1.577350 * lx) / (2 * ly - 0.788675 * lx));
          CG2 = ((0.288675 * lx) / 3);
          CG3 = (lx / 6) * ((3 * ly - 1.577350 * lx) / (2 * ly - 0.788675 * lx));
          CG4 = (lx / 6);
        } else {
          CG1 = ((0.633975 * ly) / 3);
          CG2 = ((0.366025 * ly) / 3) * ((3 * lx - 2.535898 * ly) / (2 * lx - 1.267949 * ly));
          CG3 = ((0.633975 * ly) / 3);
          CG4 = ((0.633975 * ly) / 3) * ((3 * lx - 2.535898 * ly) / (2 * lx - 1.267949 * ly));
        }
      } else if (tipo === 15) {
        if (lx <= 0.788675 * ly) {
          CG1 = ((0.633975 * lx) / 3) * ((3 * ly - 2.535898 * lx) / (2 * ly - 1.267949 * lx));
          CG2 = ((0.633975 * lx) / 3);
          CG3 = ((0.366025 * lx) / 3) * ((3 * ly - 2.535898 * lx) / (2 * ly - 1.267949 * lx));
          CG4 = ((0.633975 * lx) / 3);
        } else {
          CG1 = (ly / 6);
          CG2 = (ly / 6) * ((3 * lx - 1.577350 * ly) / (2 * lx - 0.788675 * ly));
          CG3 = ((0.288675 * ly) / 3);
          CG4 = (ly / 6) * ((3 * lx - 1.577350 * ly) / (2 * lx - 0.788675 * ly));
        }
      } else if (tipo === 16) {
        if (lx <= ly) {
          CG1 = (lx / 6) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG2 = (lx / 6);
          CG3 = (lx / 6) * ((3 * ly - 2 * lx) / (2 * ly - lx));
          CG4 = (lx / 6);
        } else {
          CG1 = (ly / 6);
          CG2 = (ly / 6) * ((3 * lx - 2 * ly) / (2 * lx - ly));
          CG3 = (ly / 6);
          CG4 = (ly / 6) * ((3 * lx - 2 * ly) / (2 * lx - ly));
        }
      }
      return { CG1, CG2, CG3, CG4 };
    }

	// Função para calcular os centros geométricos de cada região da laje corrigidos por K
	function computeCGK(lx, ly, CG1, CG2, CG3, CG4, RK) {
	  let CG1K, CG2K, CG3K, CG4K;
		if (lx <= ly) {
		  CG1K = CG1;;
          CG2K = CG2 / RK;
          CG3K = CG3;
          CG4K = CG4 / RK;
		} else {
		  CG1K = CG1 / RK;
          CG2K = CG2;
          CG3K = CG3 / RK;
          CG4K = CG4;
		}
	  return { CG1K, CG2K, CG3K, CG4K };
	}

    // Função para calcular as distâncias perpendinculares aos eixos de rotação
    function computeLp(tipo, lx, ly) {
      let Lp1, Lp2, Lp3, Lp4;
      if (tipo === 1) {
        if (lx <= ly) {
          Lp1 = (0.5 * lx);
          Lp2 = (0.5 * lx);
          Lp3 = (0.5 * lx);
          Lp4 = (0.5 * lx);
        } else {
          Lp1 = (0.5 * ly);
          Lp2 = (0.5 * ly);
          Lp3 = (0.5 * ly);
          Lp4 = (0.5 * ly);
        }
      } else if (tipo === 2) {
        if (lx <= 1.366025 * ly) {
          Lp1 = (0.633975 * lx);
          Lp2 = (0.366025 * lx);
          Lp3 = (0.366025 * lx);
          Lp4 = (0.366025 * lx);
        } else {
          Lp1 = (0.5 * ly) * (Math.sqrt(3));
          Lp2 = (0.5 * ly);
          Lp3 = (0.5 * ly);
          Lp4 = (0.5 * ly);
        }
      } else if (tipo === 3) {
        if (lx <= 0.732051 * ly) {
          Lp1 = (0.5 * lx);
          Lp2 = (0.5 * lx) * (Math.sqrt(3));
          Lp3 = (0.5 * lx);
          Lp4 = (0.5 * lx);
        } else {
          Lp1 = (0.366025 * ly);
          Lp2 = (0.633975 * ly);
          Lp3 = (0.366025 * ly);
          Lp4 = (0.366025 * ly);
        }
      } else if (tipo === 4) {
        if (lx <= 1.366025 * ly) {
          Lp1 = (0.366025 * lx);
          Lp2 = (0.366025 * lx);
          Lp3 = (0.633975 * lx);
          Lp4 = (0.366025 * lx);
        } else {
          Lp1 = (0.5 * ly);
          Lp2 = (0.5 * ly);
          Lp3 = (0.5 * ly) * (Math.sqrt(3));
          Lp4 = (0.5 * ly);
        }
      } else if (tipo === 5) {
        if (lx <= 0.732051 * ly) {
          Lp1 = (0.5 * lx);
          Lp2 = (0.5 * lx);
          Lp3 = (0.5 * lx);
          Lp4 = (0.5 * lx) * (Math.sqrt(3));
        } else {
          Lp1 = (0.366025 * ly);
          Lp2 = (0.366025 * ly);
          Lp3 = (0.366025 * ly);
          Lp4 = (0.633975 * ly);
        }
      } else if (tipo === 6) {
        if (lx <= ly) {
          Lp1 = (0.633975 * lx);
          Lp2 = (0.633975 * lx);
          Lp3 = (0.366025 * lx);
          Lp4 = (0.366025 * lx);
        } else {
          Lp1 = (0.633975 * ly);
          Lp2 = (0.633975 * ly);
          Lp3 = (0.366025 * ly);
          Lp4 = (0.366025 * ly);
        }
      } else if (tipo === 7) {
        if (lx <= ly) {
          Lp1 = (0.366025 * lx);
          Lp2 = (0.633975 * lx);
          Lp3 = (0.633975 * lx);
          Lp4 = (0.366025 * lx);
        } else {
          Lp1 = (0.366025 * ly);
          Lp2 = (0.633975 * ly);
          Lp3 = (0.633975 * ly);
          Lp4 = (0.366025 * ly);
        }
      } else if (tipo === 8) {
        if (lx <= ly) {
          Lp1 = (0.366025 * lx);
          Lp2 = (0.366025 * lx);
          Lp3 = (0.633975 * lx);
          Lp4 = (0.633975 * lx);
        } else {
          Lp1 = (0.366025 * ly);
          Lp2 = (0.366025 * ly);
          Lp3 = (0.633975 * ly);
          Lp4 = (0.633975 * ly);
        }
      } else if (tipo === 9) {
        if (lx <= ly) {
          Lp1 = (0.633975 * lx);
          Lp2 = (0.366025 * lx);
          Lp3 = (0.366025 * lx);
          Lp4 = (0.633975 * lx);
        } else {
          Lp1 = (0.633975 * ly);
          Lp2 = (0.366025 * ly);
          Lp3 = (0.366025 * ly);
          Lp4 = (0.633975 * ly);
        }
      } else if (tipo === 10) {
        if (lx <= 1.732051 * ly) {
          Lp1 = (0.500000 * lx);
          Lp2 = (0.288675 * lx);
          Lp3 = (0.500000 * lx);
          Lp4 = (0.288675 * lx);
        } else {
          Lp1 = (0.5 * ly) * (Math.sqrt(3));
          Lp2 = (0.5 * ly);
          Lp3 = (0.5 * ly) * (Math.sqrt(3));
          Lp4 = (0.5 * ly);
        }
      } else if (tipo === 11) {
        if (lx <= 0.577350 * ly) {
          Lp1 = (0.5 * lx);
          Lp2 = (0.5 * lx) * (Math.sqrt(3));
          Lp3 = (0.5 * lx);
          Lp4 = (0.5 * lx) * (Math.sqrt(3));
        } else {
          Lp1 = (0.288675 * ly);
          Lp2 = (0.500000 * ly);
          Lp3 = (0.288675 * ly);
          Lp4 = (0.500000 * ly);
        }
      } else if (tipo === 12) {
        if (lx <= 1.267949 * ly) {
          Lp1 = (0.500000 * lx);
          Lp2 = (0.500000 * lx);
          Lp3 = (0.500000 * lx);
          Lp4 = (0.288675 * lx);
        } else {
          Lp1 = (0.633975 * ly);
          Lp2 = (0.633975 * ly);
          Lp3 = (0.633975 * ly);
          Lp4 = (0.366025 * ly);
        }
      } else if (tipo === 13) {
        if (lx <= 0.788675 * ly) {
          Lp1 = (0.366025 * lx);
          Lp2 = (0.633975 * lx);
          Lp3 = (0.633975 * lx);
          Lp4 = (0.633975 * lx);
        } else {
          Lp1 = (0.288675 * ly);
          Lp2 = (0.500000 * ly);
          Lp3 = (0.500000 * ly);
          Lp4 = (0.500000 * ly);
        }
      } else if (tipo === 14) {
        if (lx <= 1.267949 * ly) {
          Lp1 = (0.500000 * lx);
          Lp2 = (0.288675 * lx);
          Lp3 = (0.500000 * lx);
          Lp4 = (0.500000 * lx);
        } else {
          Lp1 = (0.633975 * ly);
          Lp2 = (0.366025 * ly);
          Lp3 = (0.633975 * ly);
          Lp4 = (0.633975 * ly);
        }
      } else if (tipo === 15) {
        if (lx <= 0.788675 * ly) {
          Lp1 = (0.633975 * lx);
          Lp2 = (0.633975 * lx);
          Lp3 = (0.366025 * lx);
          Lp4 = (0.633975 * lx);
        } else {
          Lp1 = (0.500000 * ly);
          Lp2 = (0.500000 * ly);
          Lp3 = (0.288675 * ly);
          Lp4 = (0.500000 * ly);
        }
      } else if (tipo === 16) {
        if (lx <= ly) {
          Lp1 = (0.5 * lx);
          Lp2 = (0.5 * lx);
          Lp3 = (0.5 * lx);
          Lp4 = (0.5 * lx);
        } else {
          Lp1 = (0.5 * ly);
          Lp2 = (0.5 * ly);
          Lp3 = (0.5 * ly);
          Lp4 = (0.5 * ly);
        }
      }
      return { Lp1, Lp2, Lp3, Lp4 };
    }

	// Função para calcular as distâncias perpendinculares aos eixos de rotação corrigidas por K
	function computeLpK(lx, ly, Lp1, Lp2, Lp3, Lp4, RK) {
	  let Lp1K, Lp2K, Lp3K, Lp4K;
		if (lx <= ly) {
		  Lp1K = Lp1;;
          Lp2K = Lp2 / RK;
          Lp3K = Lp3;
          Lp4K = Lp4 / RK;
		} else {
		  Lp1K = Lp1 / RK;
          Lp2K = Lp2;
          Lp3K = Lp3 / RK;
          Lp4K = Lp4;
		}
	  return { Lp1K, Lp2K, Lp3K, Lp4K };
	}
        
    // Função para calcular deltas
    function computeDeltas(CG1, CG2, CG3, CG4, Lp1, Lp2, Lp3, Lp4) {
      let delta1, delta2, delta3, delta4;
        delta1 = CG1 / Lp1;
        delta2 = CG2 / Lp2;
        delta3 = CG3 / Lp3;
        delta4 = CG4 / Lp4;
      return { delta1, delta2, delta3, delta4 };
    }

    // Função para calcular thetas
    function computeThetas(Lp1K, Lp2K, Lp3K, Lp4K) {
      let theta1, theta2, theta3, theta4;
        theta1 = (1 / Lp1K);
        theta2 = (1 / Lp2K);
        theta3 = (1 / Lp3K);
        theta4 = (1 / Lp4K);
      return { theta1, theta2, theta3, theta4 };
    }
      
    // Função para calcular trabalho externo
    function computeWe(F1K, F2K, F3K, F4K, delta1, delta2, delta3, delta4) {
      let We;
        We = (F1K * delta1) + (F2K * delta2) + (F3K * delta3) + (F4K * delta4);
      return { We };
    }

    // Função para calcular trabalho interno
    function computeWi(tipo, lx, ly, theta1, theta2, theta3, theta4) {
      let Wi;
      if (tipo === 1) {
        Wi = (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 2) {
		Wi = (ly * theta1) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 3) {
		Wi = (lx * theta2) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 4) {
		Wi = (ly * theta3) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 5) {
		Wi = (lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 6) {
		Wi = (ly * theta1 + lx * theta2) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 7) {
		Wi = (lx * theta2 + ly * theta3) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 8) {
		Wi = (ly * theta3 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 9) {
		Wi = (ly * theta1 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 10) {
		Wi = (ly * theta1 + ly * theta3) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 11) {
		Wi = (lx * theta2 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 12) {
		Wi = (ly * theta1 + lx * theta2 + ly * theta3) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 13) {
		Wi = (lx * theta2 + ly * theta3 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 14) {
		Wi = (ly * theta1 + ly * theta3 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 15) {
		Wi = (ly * theta1 + lx * theta2 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
      } else if (tipo === 16) {
		Wi = (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4) + (2 / 3) * (ly * theta1 + lx * theta2 + ly * theta3 + lx * theta4);
	  }
      return { Wi };
    }

    // Função para calcular Mp
    function computeMp(We, Wi) {
      let Mp;
        Mp = We / Wi;
      return { Mp };
    }

    // Função para calcular momentos de cálculo
    function computeMsd(lx, ly, Mp, K) {
      let Mx1, Mx2, My1, My2;
		if (lx <= ly) {
          Mx1 = - Mp * 1.1;
          Mx2 = - (2 / 3) * Mx1;
          My1 = K * Mx1;
          My2 = - (2/ 3) * My1;
		} else {
		  My1 = - Mp * 1.1;
          My2 = - (2 / 3) * My1;
          Mx1 = K * My1;
          Mx2 = - (2/ 3) * Mx1;	
		}
      return { Mx1, Mx2, My1, My2 };
    }
		
	// Função para calcular os resultados dos momentos de cálculo aplicáveis a cada tipo de laje
	function computeMomentos (tipo, Mx1, Mx2, My1, My2) {
      let Mxp, Myp, Mxn, Myn;
		if (tipo === 1) {
			Mxp = Mx2;
			Myp = My2;
			Mxn = 0;
			Myn = 0;	
		} else if (tipo === 2  || tipo === 4 || tipo === 10) {
			Mxp = Mx2;
			Myp = My2;
			Mxn = Mx1;
			Myn = 0;
		} else if (tipo === 3  || tipo === 5 || tipo === 11) {
			Mxp = Mx2;
			Myp = My2;
			Mxn = 0;
			Myn = My1;
		} else if (tipo === 6  || tipo === 7 || tipo === 8 || tipo === 9 || tipo === 12 || tipo === 13 || tipo === 14 || tipo === 15 || tipo === 16) {
			Mxp = Mx2;
			Myp = My2;
			Mxn = Mx1;
			Myn = My1;
	}
		return { Mxp, Myp, Mxn, Myn };
	}
		
	// Função para calcular os coeficientes (processo inverso - momentos -> coeficientes)
	function computeCoeficientes(q, lx, Mxp, Myp, Mxn, Myn) {
      let mx = 0, my = 0, nx = 0, ny = 0;
	  
	  const QUINHAO = q * (Math.pow(lx, 2));
		
        if (Mxp !== 0) mx = QUINHAO / Mxp;
        if (Myp !== 0) my = QUINHAO / Myp;
        if (Mxn !== 0) nx = - QUINHAO / Mxn;
        if (Myn !== 0) ny = - QUINHAO / Myn;
	
	    return { mx, my, nx, ny };
	}

    // Função para desenhar 5 linhas internas para laje tipo 1
    function drawLajeTipo1(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
	
      if (lx <= ly) {
        // Linha 1: de (0,0) até (0.5*lx, 0.5*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.5*lx, 0.5*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.5*lx) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(0.5 * lx, 0.5 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > ly
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(0.5 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 2.
    function drawLajeTipo2(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= 1.366025 * ly) {
        // Linha 1: de (0,0) até (0.633975*lx, 0.366025*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.633975*lx, ly - 0.366025*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.633975*lx, ly - 0.366025*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.633975*lx, 0.366025*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.633975 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*lx, 0.366025*lx) até (0.633975*lx, ly - 0.366025*lx)
        start = localToCanvas(0.633975 * lx, 0.366025 * lx);
        end = localToCanvas(0.633975 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > 1.366025 * ly
        // Linha 1: de (0,0) até (0.866025*ly, 0.5*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.866025*ly, 0.5*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.5*ly, 0.5*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.5*ly, 0.5*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.866025*ly, 0.5*ly) até (lx - 0.5*ly, 0.5*ly)
        start = localToCanvas(0.866025 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 3.
    function drawLajeTipo3(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= 0.732051 * ly) {
        // Linha 1: de (0,0) até (0.5*lx, 0.5*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.5*lx, ly - 0.866025*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.5*lx, ly - 0.866025*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.5*lx, 0.5*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.5*lx) até (0.5*lx, ly - 0.866025*lx)
        start = localToCanvas(0.5 * lx, 0.5 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > 0.732051 * ly
        // Linha 1: de (0,0) até (0.366025*ly, 0.366025*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*ly, 0.366025*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.366025*ly, 0.366025*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.366025*ly, 0.366025*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*ly, 0.366025*ly) até (lx - 0.366025*ly, 0.366025*ly)
        start = localToCanvas(0.366025 * ly, 0.366025 * ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 4.
    function drawLajeTipo4(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= 1.366025 * ly) {
        // Linha 1: de (0,0) até (0.366025*lx, 0.366025*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*lx, ly - 0.366025*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.366025*lx, ly - 0.366025*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.366025*lx, 0.366025*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.366025 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*lx, 0.366025*lx) até (0.366025*lx, ly - 0.366025*lx)
        start = localToCanvas(0.366025 * lx, 0.366025 * lx);
        end = localToCanvas(0.366025 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > 1.366025 * ly
        // Linha 1: de (0,0) até (0.5*ly, 0.5*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.5*ly, 0.5*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.866025*ly, 0.5*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.866025*ly, 0.5*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*ly, 0.5*ly) até (lx - 0.866025*ly, 0.5*ly)
        start = localToCanvas(0.5 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 5.
    function drawLajeTipo5(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= 0.732051 * ly) {
        // Linha 1: de (0,0) até (0.5*lx, 0.866025*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.5*lx, 0.866025*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.866025*lx) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(0.5 * lx, 0.866025 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > 0.732051 * ly
        // Linha 1: de (0,0) até (0.366025*ly, 0.633975*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*ly, 0.633975*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.366025*ly, 0.633975*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.366025*ly, 0.633975*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*ly, 0.633975*ly) até (lx - 0.366025*ly, 0.633975*ly)
        start = localToCanvas(0.366025 * ly, 0.633975 * ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 6.
    function drawLajeTipo6(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= ly) {
        // Linha 1: de (0,0) até (0.633975*lx, 0.366025*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.633975*lx, ly - 0.633975*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.633975*lx, ly - 0.633975*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.633975*lx, 0.366025*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.633975 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*lx, 0.366025*lx) até (0.633975*lx, ly - 0.633975*lx)
        start = localToCanvas(0.633975 * lx, 0.366025 * lx);
        end = localToCanvas(0.633975 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > ly
        // Linha 1: de (0,0) até (0.633975*ly, 0.366025*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.633975*ly, 0.366025*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.366025*ly, 0.366025*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.366025*ly, 0.366025*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*ly, 0.366025*ly) até (lx - 0.366025*ly, 0.366025*ly)
        start = localToCanvas(0.633975 * ly, 0.366025 * ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 7.
    function drawLajeTipo7(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= ly) {
        // Linha 1: de (0,0) até (0.366025*lx, 0.366025*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*lx, ly - 0.633975*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.366025*lx, ly - 0.633975*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.366025*lx, 0.366025*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.366025 * lx, 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*lx, 0.366025*lx) até (0.366025*lx, ly - 0.633975*lx)
        start = localToCanvas(0.366025 * lx, 0.366025 * lx);
        end = localToCanvas(0.366025 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > ly
        // Linha 1: de (0,0) até (0.366025*ly, 0.366025*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*ly, 0.366025*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.633975*ly, 0.366025*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.633975*ly, 0.366025*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*ly, 0.366025*ly) até (lx - 0.633975*ly, 0.366025*ly)
        start = localToCanvas(0.366025 * ly, 0.366025 * ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 8.
    function drawLajeTipo8(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= ly) {
        // Linha 1: de (0,0) até (0.366025*lx, 0.633975*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*lx, ly - 0.366025*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.366025*lx, ly - 0.366025*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.366025*lx, 0.633975*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.366025 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*lx, 0.633975*lx) até (0.366025*lx, ly - 0.366025*lx)
        start = localToCanvas(0.366025 * lx, 0.633975 * lx);
        end = localToCanvas(0.366025 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > ly
        // Linha 1: de (0,0) até (0.366025*ly, 0.633975*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.366025*ly, 0.633975*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.633975*ly, 0.633975*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.633975*ly, 0.633975*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*ly, 0.633975*ly) até (lx - 0.633975*ly, 0.633975*ly)
        start = localToCanvas(0.366025 * ly, 0.633975 * ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 9.
    function drawLajeTipo9(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
      
      if (lx <= ly) {
        // Linha 1: de (0,0) até (0.633975*lx, 0.633975*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.633975*lx, ly - 0.366025*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (0.633975*lx, ly - 0.366025*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (0.633975*lx, 0.633975*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.633975 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*lx, 0.633975*lx) até (0.633975*lx, ly - 0.366025*lx)
        start = localToCanvas(0.633975 * lx, 0.633975 * lx);
        end = localToCanvas(0.633975 * lx, ly - 0.366025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Caso: lx > ly
        // Linha 1: de (0,0) até (0.633975*ly, 0.633975*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0,ly) até (0.633975*ly, 0.633975*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx,ly) até (lx - 0.366025*ly, 0.633975*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx,0) até (lx - 0.366025*ly, 0.633975*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*ly, 0.633975*ly) até (lx - 0.366025*ly, 0.633975*ly)
        start = localToCanvas(0.633975 * ly, 0.633975 * ly);
        end = localToCanvas(lx - 0.366025 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 10
    function drawLajeTipo10(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
		
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= 1.732051 * ly) {
        // Linha 1: de (0, 0) até (0.5*lx, 0.288675*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.5*lx, ly - 0.288675*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (0.5*lx, ly - 0.288675*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (0.5*lx, 0.288675*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.288675*lx) até (0.5*lx, ly - 0.288675*lx)
        start = localToCanvas(0.5 * lx, 0.288675 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Se lx > 1.732051*ly
        // Linha 1: de (0, 0) até (0.866025*ly, 0.5*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.866025*ly, 0.5*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (lx - 0.866025*ly, 0.5*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (lx - 0.866025*ly, 0.5*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.866025*ly, 0.5*ly) até (lx - 0.866025*ly, 0.5*ly)
        start = localToCanvas(0.866025 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.866025 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 11
    function drawLajeTipo11(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
		
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= 0.577350 * ly) {
        // Linha 1: de (0, 0) até (0.5*lx, 0.866025*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.5*lx, ly - 0.866025*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (0.5*lx, ly - 0.866025*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (0.5*lx, 0.866025*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.866025*lx) até (0.5*lx, ly - 0.866025*lx)
        start = localToCanvas(0.5 * lx, 0.866025 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.866025 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Se lx > 0.577350*ly
        // Linha 1: de (0, 0) até (0.288675*ly, 0.5*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.288675*ly, 0.5*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (lx - 0.288675*ly, 0.5*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (lx - 0.288675*ly, 0.5*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.288675*ly, 0.5*ly) até (lx - 0.288675*ly, 0.5*ly)
        start = localToCanvas(0.288675 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 12
    function drawLajeTipo12(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
		
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= 1.267949 * ly) {
        // Linha 1: de (0, 0) até (0.5*lx, 0.288675*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (0.5*lx, 0.288675*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.288675*lx) até (0.5*lx, ly - 0.5*lx)
        start = localToCanvas(0.5 * lx, 0.288675 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Se lx > 1.267945*ly
        // Linha 1: de (0, 0) até (0.633975*ly, 0.366025*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.633975*ly, 0.366025*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (lx - 0.633975*ly, 0.366025*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (lx - 0.633975*ly, 0.366025*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*ly, 0.366025*ly) até (lx - 0.633975*ly, 0.366025*ly)
        start = localToCanvas(0.633975 * ly, 0.366025 * ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.366025 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 13
    function drawLajeTipo13(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
		
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= 0.788675 * ly) {
        // Linha 1: de (0, 0) até (0.366025*lx, 0.633975*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.366025 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.366025*lx, ly - 0.633975*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (0.366025*lx, ly - 0.633975*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.366025 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (0.366025*lx, 0.633975*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.366025 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.366025*lx, 0.633975*lx) até (0.366025*lx, ly - 0.633975*lx)
        start = localToCanvas(0.366025 * lx, 0.633975 * lx);
        end = localToCanvas(0.366025 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Se lx > 0.788675*ly
        // Linha 1: de (0, 0) até (0.288675*ly, 0.5*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.288675*ly, 0.5*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (lx - 0.5*ly, 0.5*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (lx - 0.5*ly, 0.5*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.288675*ly, 0.5*ly) até (lx - 0.5*ly, 0.5*ly)
        start = localToCanvas(0.288675 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 14
    function drawLajeTipo14(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
		
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (rectWidth <= 1.267945 * rectHeight) {
        // Linha 1: de (0, 0) até (0.5*lx, 0.5*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.5*lx, ly - 0.288675*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (0.5*lx, ly - 0.288675*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (0.5*lx, 0.5*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*lx, 0.5*lx) até (0.5*lx, ly - 0.288675*lx)
        start = localToCanvas(0.5 * lx, 0.5 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.288675 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Se lx > 1.267945*ly
        // Linha 1: de (0, 0) até (0.633975*ly, 0.633975*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.633975*ly, 0.633975*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (lx - 0.633975*ly, 0.633975*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (lx - 0.633975*ly, 0.633975*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*ly, 0.633975*ly) até (lx - 0.633975*ly, 0.633975*ly)
        start = localToCanvas(0.633975 * ly, 0.633975 * ly);
        end = localToCanvas(lx - 0.633975 * ly, 0.633975 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 15
    function drawLajeTipo15(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
		
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= 0.788675 * ly) {
        // Linha 1: de (0, 0) até (0.633975*lx, 0.633975*lx)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.633975 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.633975*lx, ly - 0.633975*lx)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (0.633975*lx, ly - 0.633975*lx)
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.633975 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (0.633975*lx, 0.633975*lx)
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.633975 * lx, 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.633975*lx, 0.633975*lx) até (0.633975*lx, ly - 0.633975*lx)
        start = localToCanvas(0.633975 * lx, 0.633975 * lx);
        end = localToCanvas(0.633975 * lx, ly - 0.633975 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        // Se lx > 0.788675*ly
        // Linha 1: de (0, 0) até (0.5*ly, 0.5*ly)
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 2: de (0, ly) até (0.5*ly, 0.5*ly)
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 3: de (lx, ly) até (lx - 0.288675*ly, 0.5*ly)
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 4: de (lx, 0) até (lx - 0.288675*ly, 0.5*ly)
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        // Linha 5: de (0.5*ly, 0.5*ly) até (lx - 0.288675*ly, 0.5*ly)
        start = localToCanvas(0.5 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.288675 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }

    // Função para desenhar 5 linhas internas para laje tipo 16
    function drawLajeTipo16(rectX, rectY, rectWidth, rectHeight) {
      function localToCanvas(localX, localY) {
        return { cx: rectX + localX, cy: rectY + (rectHeight - localY) };
      }
      ctx3.strokeStyle = 'gray';
      ctx3.lineWidth = 2;
      ctx3.setLineDash([5, 5]);
	  const lx = rectWidth;
      const ly = rectHeight;
		
      if (lx <= ly) {
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(lx, ly);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(lx, 0);
        end = localToCanvas(0.5 * lx, 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(0.5 * lx, 0.5 * lx);
        end = localToCanvas(0.5 * lx, ly - 0.5 * lx);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      } else {
        let start = localToCanvas(0, 0);
        let end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(0, ly);
        end = localToCanvas(0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(lx, ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(lx, 0);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
        start = localToCanvas(0.5 * ly, 0.5 * ly);
        end = localToCanvas(lx - 0.5 * ly, 0.5 * ly);
        ctx3.beginPath();
        ctx3.moveTo(start.cx, start.cy);
        ctx3.lineTo(end.cx, end.cy);
        ctx3.stroke();
      }
      ctx3.setLineDash([]);
    }
		
	}
		

const inputIdsToListen = ['lx', 'ly', 'q'];
const checkboxIdsToListen = ['engaste1', 'engaste2', 'engaste3', 'engaste4'];

inputIdsToListen.forEach(id => {
  const element = document.getElementById(id);
  if (element) {
    element.addEventListener('input', runAllComputationsAndTriggerAutoSave);
  } else {
    console.error("Elemento de input não encontrado para listener: " + id);
  }
});

checkboxIdsToListen.forEach(id => {
  const element = document.getElementById(id);
  if (element) {
    // Garanta que não haja outros listeners de 'change' para esta finalidade
    element.addEventListener('change', runAllComputationsAndTriggerAutoSave);
  } else {
    console.error("Elemento de checkbox não encontrado para listener: " + id);
  }
});


window.addEventListener('load', () => {
  const canvas1 = document.getElementById('canvas1');
  const ctx1 = canvas1.getContext('2d');
  if (typeof fixDpi === 'function') fixDpi(canvas1, ctx1); else console.error("fixDpi não definida");
  if (typeof computeMarcus === 'function') computeMarcus(); else console.error("computeMarcus não definida");
});
window.addEventListener('load', () => {
  const canvas2 = document.getElementById('canvas2');
  const ctx2 = canvas2.getContext('2d');
  if (typeof fixDpi === 'function') fixDpi(canvas2, ctx2);
  if (typeof computeCzerny === 'function') computeCzerny(); else console.error("computeCzerny não definida");
});
window.addEventListener('load', () => {
  const canvas3 = document.getElementById('canvas3');
  const ctx3 = canvas3.getContext('2d');
  if (typeof fixDpi === 'function') fixDpi(canvas3, ctx3);
  if (typeof computeCharneiras === 'function') computeCharneiras(); else console.error("computeCharneiras não definida");
});

function runAllComputationsAndTriggerAutoSave() {
  // Chama as funções de cálculo principais.
  computeMarcus();
  computeCzerny();
  computeCharneiras();

  // Chama a função de salvamento automático
  if (typeof window.autoSaveCurrentConfiguration === 'function') {
    window.autoSaveCurrentConfiguration();
  } else {
    console.warn("Atenção: A função window.autoSaveCurrentConfiguration não foi encontrada. O salvamento automático não funcionará.");
  }
}
	  
  </script>
  <script>
  let todasAsConfiguracoes = [];
  let contadorConfiguracao = 0;

  const parametrosParaExportar = [
    { categoria: "Entradas", parametro: "Lx (m)", path: config => config.dados.entradas.Lx },
    { categoria: "Entradas", parametro: "Ly (m)", path: config => config.dados.entradas.Ly },
    { categoria: "Entradas", parametro: "q (kN/m2)", path: config => config.dados.entradas.q },
    { categoria: "Entradas", parametro: "Tipo de Laje", path: config => config.dados.entradas.TipoLaje },
    { categoria: "", parametro: "", path: null }, // Linha de separação

    { categoria: "Metodo de Marcus", parametro: "Lambda", path: config => config.dados.marcus.Lambda },
    { categoria: "Metodo de Marcus", parametro: "m'x", path: config => config.dados.marcus.mx_marcus },
    { categoria: "Metodo de Marcus", parametro: "m'y", path: config => config.dados.marcus.my_marcus },
    { categoria: "Metodo de Marcus", parametro: "n'x", path: config => config.dados.marcus.nx_marcus },
    { categoria: "Metodo de Marcus", parametro: "n'y", path: config => config.dados.marcus.ny_marcus },
    { categoria: "Metodo de Marcus", parametro: "Mx+ (kN.m)", path: config => config.dados.marcus.Mx_positivo },
    { categoria: "Metodo de Marcus", parametro: "My+ (kN.m)", path: config => config.dados.marcus.My_positivo },
    { categoria: "Metodo de Marcus", parametro: "Mx- (kN.m)", path: config => config.dados.marcus.Mx_negativo },
    { categoria: "Metodo de Marcus", parametro: "My- (kN.m)", path: config => config.dados.marcus.My_negativo },
    { categoria: "", parametro: "", path: null },

    { categoria: "Metodo de Czerny", parametro: "Epsilon", path: config => config.dados.czerny.Epsilon },
    { categoria: "Metodo de Czerny", parametro: "mx", path: config => config.dados.czerny.mx_czerny },
    { categoria: "Metodo de Czerny", parametro: "my", path: config => config.dados.czerny.my_czerny },
    { categoria: "Metodo de Czerny", parametro: "nx", path: config => config.dados.czerny.nx_czerny },
    { categoria: "Metodo de Czerny", parametro: "ny", path: config => config.dados.czerny.ny_czerny },
    { categoria: "Metodo de Czerny", parametro: "Mx+ (kN.m)", path: config => config.dados.czerny.Mx_positivo },
    { categoria: "Metodo de Czerny", parametro: "My+ (kN.m)", path: config => config.dados.czerny.My_positivo },
    { categoria: "Metodo de Czerny", parametro: "Mx- (kN.m)", path: config => config.dados.czerny.Mx_negativo },
    { categoria: "Metodo de Czerny", parametro: "My- (kN.m)", path: config => config.dados.czerny.My_negativo },
    { categoria: "", parametro: "", path: null },

    { categoria: "Linhas de Ruptura", parametro: "mx", path: config => config.dados.ruptura.mx_charneiras },
    { categoria: "Linhas de Ruptura", parametro: "my", path: config => config.dados.ruptura.my_charneiras },
    { categoria: "Linhas de Ruptura", parametro: "nx", path: config => config.dados.ruptura.nx_charneiras },
    { categoria: "Linhas de Ruptura", parametro: "ny", path: config => config.dados.ruptura.ny_charneiras },
    { categoria: "Linhas de Ruptura", parametro: "Mx+ (kN.m)", path: config => config.dados.ruptura.Mx_positivo },
    { categoria: "Linhas de Ruptura", parametro: "My+ (kN.m)", path: config => config.dados.ruptura.My_positivo },
    { categoria: "Linhas de Ruptura", parametro: "Mx- (kN.m)", path: config => config.dados.ruptura.Mx_negativo },
    { categoria: "Linhas de Ruptura", parametro: "My- (kN.m)", path: config => config.dados.ruptura.My_negativo }
  ];

  function coletarResultados() {
    const tipoLajeAtual = (typeof getTipoLaje === 'function') ? getTipoLaje() : 'N/A (getTipoLaje não definida)';

    const resultados = {
      entradas: {
        Lx: document.getElementById('lx').value,
        Ly: document.getElementById('ly').value,
        q: document.getElementById('q').value,
        TipoLaje: document.getElementById('tipoLajeOutput').innerText || tipoLajeAtual
      },
      marcus: {
        Lambda: document.getElementById('lambdaMarcusoutput').innerText,
        mx_marcus: document.getElementById('mxMarcusoutput').innerText,
        my_marcus: document.getElementById('myMarcusoutput').innerText,
        nx_marcus: document.getElementById('nxMarcusoutput').innerText,
        ny_marcus: document.getElementById('nyMarcusoutput').innerText,
        Mx_positivo: document.getElementById('MxpositivoMarcusoutput').innerText.replace(' kN.m', ''),
        My_positivo: document.getElementById('MypositivoMarcusoutput').innerText.replace(' kN.m', ''),
        Mx_negativo: document.getElementById('MxnegativoMarcusoutput').innerText.replace(' kN.m', ''),
        My_negativo: document.getElementById('MynegativoMarcusoutput').innerText.replace(' kN.m', '')
      },
      czerny: {
        Epsilon: document.getElementById('epsilonoutput').innerText,
        mx_czerny: document.getElementById('mxCzernyoutput').innerText,
        my_czerny: document.getElementById('myCzernyoutput').innerText,
        nx_czerny: document.getElementById('nxCzernyoutput').innerText,
        ny_czerny: document.getElementById('nyCzernyoutput').innerText,
        Mx_positivo: document.getElementById('MxpositivoCzernyoutput').innerText.replace(' kN.m', ''),
        My_positivo: document.getElementById('MypositivoCzernyoutput').innerText.replace(' kN.m', ''),
        Mx_negativo: document.getElementById('MxnegativoCzernyoutput').innerText.replace(' kN.m', ''),
        My_negativo: document.getElementById('MynegativoCzernyoutput').innerText.replace(' kN.m', '')
      },
      ruptura: {
        mx_charneiras: document.getElementById('mxRupturaoutput').innerText,
        my_charneiras: document.getElementById('myRupturaoutput').innerText,
        nx_charneiras: document.getElementById('nxRupturaoutput').innerText,
        ny_charneiras: document.getElementById('nyRupturaoutput').innerText,
        Mx_positivo: document.getElementById('MxpositivoRupturaoutput').innerText.replace(' kN.m', ''),
        My_positivo: document.getElementById('MypositivoRupturaoutput').innerText.replace(' kN.m', ''),
        Mx_negativo: document.getElementById('MxnegativoRupturaoutput').innerText.replace(' kN.m', ''),
        My_negativo: document.getElementById('MynegativoRupturaoutput').innerText.replace(' kN.m', '')
      }
    };
    return resultados;
  }

  function atualizarContadorConfiguracoes() {
    const counterElement = document.getElementById('configCounter');
    if (counterElement) {
        counterElement.innerText = "Configurações salvas (auto): " + todasAsConfiguracoes.length;
    }
  }

  // Função para salvar automaticamente a configuração atual
  // Tornada global para ser chamada pelo primeiro script
  window.autoSaveCurrentConfiguration = function() {
    try {
      contadorConfiguracao++;
      const resultadosAtuais = coletarResultados();
      todasAsConfiguracoes.push({
        id: "Config_" + contadorConfiguracao, // ID único para cada salvamento
        dados: resultadosAtuais
      });
      atualizarContadorConfiguracoes();
    } catch (e) {
      console.error("Erro ao salvar configuração automaticamente:", e);
    }
  }

  const clearButton = document.getElementById('clearConfigsButton');
  if (clearButton) {
      clearButton.addEventListener('click', function() {
        if (confirm("Tem certeza que deseja limpar todas as configurações salvas na memória?")) {
          todasAsConfiguracoes = [];
          contadorConfiguracao = 0; // Reseta o contador de ID também
          atualizarContadorConfiguracoes();
          alert("Configurações salvas foram limpas.");
        }
      });
  }


  function exportarParaCSV() {
    if (todasAsConfiguracoes.length === 0) {
      alert("Nenhuma configuração foi salva automaticamente ainda. Faça alterações nos dados de entrada para salvar configurações.");
      return;
    }
    let csvContent = "";
    let headerRow = "Categoria;Parametro";
    todasAsConfiguracoes.forEach(config => {
      headerRow += ";" + config.id;
    });
    csvContent += headerRow + "\r\n";

    parametrosParaExportar.forEach(pInfo => {
      if (pInfo.path === null) {
        let separatorLine = ";";
        todasAsConfiguracoes.forEach(() => {
          separatorLine += ";";
        });
        csvContent += separatorLine + "\r\n";
      } else {
        let dataRow = pInfo.categoria + ";" + pInfo.parametro;
        todasAsConfiguracoes.forEach(config => {
          try {
            const valorOriginal = pInfo.path(config);
            let valorParaCSV = "";
            if (valorOriginal !== undefined && valorOriginal !== null) {
              valorParaCSV = String(valorOriginal).replace('.', ',');
            }
            dataRow += ";" + valorParaCSV;
          } catch (e) {
            console.error("Erro ao processar o path para CSV:", pInfo, config, e);
            dataRow += ";ERRO";
          }
        });
        csvContent += dataRow + "\r\n";
      }
    });

    const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "resultados.csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  const exportBtn = document.getElementById('exportButton');
  if (exportBtn) {
      exportBtn.addEventListener('click', exportarParaCSV);
  }
  
  // Inicializa o contador visual na carga da página
  window.addEventListener('load', () => {
    atualizarContadorConfiguracoes();
  });
  </script>
</body>
</html>
